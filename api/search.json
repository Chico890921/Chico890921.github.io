[{"id":"989200f113c4d8f20366415490ca243c","title":"UVA00100::The 3n+1 Problem","content":"題目連結: https://zerojudge.tw/ShowProblem?problemid=c039\n解題思路從 a 到 b 之間的所有長度都算出來，只記錄最大值就好 (可以運用函式，讓程式碼變得更單純)\n\nn=34 ==&gt;   34-&gt;17-&gt;52-&gt;26-&gt;13-&gt;40-&gt;20-&gt;10-&gt;5-&gt;16-&gt;8-&gt;4-&gt;2-&gt;1  長度為 14\n\n程式碼\n1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int al(int n) &#123;\tint len = 1;\twhile (n!=1) &#123;\t\tif (n%2==1) &#123;\t\t\tn = 3*n + 1;\t\t&#125; else &#123;\t\t\tn /= 2;\t\t&#125;\t\tlen++;\t&#125;\treturn len;&#125;int main() &#123;\tint a, b;\twhile (cin &gt;&gt; a &gt;&gt; b) &#123;\t\tint ans = 0;\t\tfor (int i=min(a, b); i&lt;=max(a, b); i++) &#123;\t\t\tans = max(al(i), ans);\t\t&#125;\t\tcout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; ans &lt;&lt; endl;\t&#125;&#125;\n—&gt;\n","slug":"UVA00100-The-3n-1-Problem","date":"2022-09-22T08:22:10.000Z","categories_index":"解題紀錄","tags_index":"CPE","author_index":"Chico"},{"id":"158821a355ec40bcc98630f487f0e4d0","title":"CSS::unicode-range","content":"\n\n\n\n\n\n\n\n\n\n\n此篇為各筆記之整理，非原創內容，資料來源可見下方連結與文後參考資料\nunicode-range 屬性使用方式123456/* &lt;unicode-range&gt; 值 */  unicode-range: U+26; /* 單一 codepoint */  unicode-range: U+0-7F;  unicode-range: U+0025-00FF; /* 區段 codepoint（含頭尾） */  unicode-range: U+4??; /* 任何尾碼的 code point，這個例子即 U+400-4FF */  unicode-range: U+0025-00FF, U+4??; /* 多重值，可包含多個 codepoint 範圍 */\n常用區段\n\n\n\n\n\n\n\n\n\nU+4E00-9FFF\n中日韓統一表意文字 (20,989 個漢字)\n\n\nU+F900-FAFF\n中日韓相容表意文字 (472 個漢字)\n\n\nU+3000-303F\n中日韓符號和標點 (漢字 15 個，諺文 2 個，共用 43 個，繼承 4 個)\n\n\nU+3200-32FF\n中日韓圍繞字元及月份 (諺文 62 個，片假名 47 個，共用 146 個)\n\n\nU+3100-312F\n注音符號 (注音字母 43 個)\n\n\nU+00-02AF\n拉丁語系 (含英文，共 688 個)\n\n\nU+0370-03FF\n希臘字母及科普特字母 (科普特字母 14 個，希臘字母 117 個，共用 4 個)\n\n\nU+3040-30FF\n日文假名 (平假名 89 個，片假名 93 個，共用 5 個，繼承 2 個)\n\n\nU+3300-33FF\n中日韓相容字元 (片假名 88 個，共用 168 個)\n\n\n\n\n參考資料CSS unicode-range 描述自定義字體中使用的字元範圍（Unicode區段）\n","slug":"CSS-unicode-range","date":"2022-09-20T18:35:48.000Z","categories_index":"","tags_index":"","author_index":"Chico"},{"id":"534252b15d2f382bf7caf6142baa16d6","title":"reverse::逆向工程核心原理::第 13 章::PE 文件格式","content":"\n\n\n\n\n\n\n\n\n\n\n此篇為各筆記之整理，部分原創內容，資料來源可見下方連結與文後參考資料\n\n\n\n\n\n\n\n\n\n\n了解 PE 結構可以修改 PE 檔案的一些屬性ex. 可以修改程式入口點、修改程式邏輯等…\n可執行檔案可執行檔案 (executable file) 指的是可以由作業系統進行加載執行的檔案可執行檔案 也稱為 PE 檔案，因為可執行檔案都遵從了 PE 結構\n不同作業系統的可執行檔案的格式\n\n\n\n\n\n\n\n\n\nwindows\nPE (Portable Executable)\n\n\nLinux\nELF(Executable and Linking Format)\n\n\n\n\n仔細的人可能會發現 PE 的全稱是 Portable Executable，其中文意思就是可移植可執行而 ELF 的全稱 Executable and Linking Format 就是可執行可鏈接格式\n那麼兩者之間的差距就出現了\nWindows 平台下的 PE 檔案結構是可移植的，也就表示其在 Windows 下是通用兼容的\n例如你在 Windows7 下的可執行檔案也可以在 Windows8、10 系統下運行而 Linux 則不一樣，不同核心編譯的可執行檔案在不同核心的環境下是無法使用的\n\n\n\n\n\n\n\n\n\n個人理解的 PE 文件結構其實就類似於 CTF Misc 題中的 jpg、png、zip 文件格式類似，當你了解了這些文件格式後，你可以通過修改二進制數據來改圖片寬高等屬性，同樣的，當你了解 Windows PE 文件結構後，你也可以修改 PE 文件的一些屬性，比如修改程序入口點甚至修改程序運行邏輯。\n哪些領域會用到 PE 文件格式 ?\n病毒、反病毒\n外掛、反外掛\n加殼、脫殼 (保護、破解)\n無原始碼修改功能、軟體中文化等\n\n如何識別 PE 檔案你想要識別一個檔案是不是 PE 格式，或者說是不是一個可執行檔案，可以根據 PE 指紋來識別：\n首先你需要找到一個可以以 16 進位打開 PE 文件的工具（010 Editor、PEbear、PEview…）然後找到一個 PE 檔案，用該工具打開 PE 檔案\n\n在文件的開始位置有一個 0x5A4D (十進制：MZ )\n接著觀察 0x003C 位置 ( 0x00E8 )  \n接著我們再去尋找 0x00E8 位置就會出現一個 0x4550 (十進制：PE )\n\n如果能用這個方法可以順利的走通整個流程找到 PE，就表示這是一個 PE 文件，同樣這也是一個 PE 指紋：\n\n\n\n\n\n\n\n\n\n\n備忘1 個位元組(byte) = 8 bits圖中 4D 為 1 byte, 5A 為 1 byte原因: 它們是 16 進位，一個數為 4 bits\nex.   4    D    5    A    0100 1101 0101 1010\n2 進位速算: 8 4 2 1 \n A  B  C  D  E  F10 11 12 13 14 15\n如上示例中我使用的是 exe 後綴的文件，但即使不是 exe 後綴的文件，例如 .sys、.dll 後綴的文件，實際上你通過這種方式會發現它們也是 PE 文件，所以我們不要只看後綴名來認定是不是 PE 文件，而要具體去看文件中的指紋。\n常見的 exe、dll、sys、 ocx、com 都屬於 PE 文件。\nPE 格式示意圖如上所述中我們可以了解到通過 PE 指紋的方式識別 PE 文件，但是我又是如何知道這是否是一個 PE 文件的呢？這是因為 PE 文件結構有一個規範和定義，如下圖所示就是 PE 文件的整體結構：\n\nPE文件分為以下四大塊，依次是:\n\n\n\n\n\n\n\n\n\n\nDOS實模式殘留數據\n\nNT文件頭\n\n節表\n\n節內容\n\n\n這幾個主要結構體分別對應的寬度如下所示：\n\n\n\n\n結構體\n寬度（位元組)\n\n\n\n\nIMAGE_DOS_HEADER\n64\n\n\nIMAGE_FILE_HEADER\n20\n\n\nIMAGE_OPTIONAL_HEADER32\n224\n\n\nIMAGE_SECTION_HEADER\n40\n\n\n\n\n\n DOS Headers在 Windows NT 之前的 Windows 系統是基於 dos 作業系統核心，為了兼容 dos 系統上可執行文件，Windows NT 在設計可執行文件格式時保留兼容了之前的格式。\nPE 文件中的 DOS 實模式殘留數據包括兩部分:  DOS 頭 +  DOS StubIMAGE_DOS_HEADER結構，這個結構佔64字節，文件前四行就是了\n\n接著是DOS stub，這個大小是不固定的，但是在上文中，我們了解到可以根據某個值定位到PE文件頭，我們可以先找到PE文件頭，這樣夾在他們之間的就是DOS塊了，在這裡就是IMAGE_DOS_HEADER結構體的e_lfanew成員，如上圖所示這裡對應的值是0xE0\nDOS MZ文件頭就是一個結構體IMAGE_DOS_HEADER，其定義如下所示\n123456789101112131415161718192021typedef struct _IMAGE_DOS_HEADER &#123;      // DOS .EXE header    WORD   e_magic;                     // Magic number    WORD   e_cblp;                      // Bytes on last page of file    WORD   e_cp;                        // Pages in file    WORD   e_crlc;                      // Relocations    WORD   e_cparhdr;                   // Size of header in paragraphs    WORD   e_minalloc;                  // Minimum extra paragraphs needed    WORD   e_maxalloc;                  // Maximum extra paragraphs needed    WORD   e_ss;                        // Initial (relative) SS value    WORD   e_sp;                        // Initial SP value    WORD   e_csum;                      // Checksum    WORD   e_ip;                        // Initial IP value    WORD   e_cs;                        // Initial (relative) CS value    WORD   e_lfarlc;                    // File address of relocation table    WORD   e_ovno;                      // Overlay number    WORD   e_res[4];                    // Reserved words    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)    WORD   e_oeminfo;                   // OEM information; e_oemid specific    WORD   e_res2[10];                  // Reserved words    LONG   e_lfanew;                    // Offset to start of PE header  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;\n它有很多成員，但我們並不需要去深入的理解每個成員的含義和作用，這是因為這個結構體是給16位平台看的，而我們現在的環境大部分都是32位和64位的，所以現在的平台不再需要這個完整的結構體了，只需要其中的兩個成員e_magic和e_lfanew。\n你可以嘗試在16進制的編輯器中去編輯某個EXE文件保留兩個成員e_magic和e_lfanew，其他的以0x00填充，然後保存文件，你會發現修改後的文件還是可以正常運行的\n\n保留這兩個成員的原因是因為它們代表著我們之前所說的PE指紋，操作系統也是根據這個來識別是否是PE文件的，所以不能夠更改、刪除（e_magic是一種標識，e_lfanew則表示PE文件頭的位置）。\n重點關注的是最後一個字段， 有時稱為 3C 字段，它指示了 windows NT PE 文件頭的偏移位置。\nDOS StubDOS塊就是夾在DOS MZ文件頭和PE文件頭之間的內容，大小不固定，即使沒有DOS存根文件也能正常運行，這裡面的內容可以根據自己的需要隨意的修改和添加，並不會影響文件的正常運行。\n\n如上圖，文件Offset 0x40~0x4D這篇區域為16位的彙編指令，在32位及以上操作系統運行程序時不會執行該指令。在DOS環境中或使用DOS調試器運行它時，會執行這段指令（因為如DOS等16位操作系統不認識PE文件，識別成DOS EXE文件，所以執行這一段）。\n在WindowsXP下，運行命令debug notepad.exe啟動notepad.exe，在出現的光標位置輸入“u”指令，會出現16位彙編指令。\n\n大概意思就是會在終端中輸出字符串“This program cannot be run in DOS mode”後就退出程序，換言之這裡DOS存根的作用就是當32位程序在16位DOS下運行時，就會提示“This program cannot be run in DOS mode”後就退出程序，作為對MS-DOS的兼容。\nNT Headers前面提到: DOS 頭的最後一個字段指示了 NT 頭的位置。\nNT 頭分為三個部分:12345typedef struct _IMAGE_NT_HEADERS &#123;    DWORD Signature; // PE标识    IMAGE_FILE_HEADER FileHeader; // 标准PE头    IMAGE_OPTIONAL_HEADER32 OptionalHeader; // 扩展PE头&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;\n其第一個是PE文件頭標誌，這裡佔4字節，也就是圖中所示的0x4550（PE標識是不能修改的，因為操作系統在啟動一個程序的時候會檢測這個標識）第二部分就是PE文件表頭IMAGE_FILE_HEADER結構，這個結構佔20字節，我們也稱之為標準PE頭\n\n繼續看PE文件頭的第三個部分PE文件表頭可選部分，我們也稱之為擴展PE頭，其就是IMAGE_OPTIONAL_HEADER32結構，默認情況下它在32位下是224 byte，在64位下是240 byte，你也可以通過IMAGE_FILE_HEADER結構的成員( SizeOfOptionalHeader )去獲取/修改擴展PE頭的寬度\n以上圖為例，SizeOfOptionalHeader 對應在 0x00F4 位址的值為 0x00E0 =&gt; 32位元 =&gt; 224 byte\n擴展PE頭之所以數據寬度較大，是因為其有一個成員是結構體數組\nFile Header標準PE頭是PE頭的第二個成員，它是如下所示的結構體\n\n123456789typedef struct _IMAGE_FILE_HEADER &#123;    WORD    Machine; // 可以运行在什么样的CPU上    WORD    NumberOfSections; // 表示节的数量    DWORD   TimeDateStamp; // 编译器填写的时间戳    DWORD   PointerToSymbolTable; // 调试相关    DWORD   NumberOfSymbols; // 调试相关    WORD    SizeOfOptionalHeader; // 扩展PE头的大小    WORD    Characteristics; // 文件属性&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n成員 Machine ( 重要 )其第一個成員Machine表示可以運行在什麼樣的CPU上，如果它的值為0x0則表示可以運行在任意的CPU上，支持在Intel 386以及後續的型號CPU運行則值為0x14c，支持64位的CPU型號則值為0x8664。\n我們可以分別在32位、64位系統上提取notepad.exe進行對比來看看這個成員（010 Editor → Tools → Compare Files…\n\n成員 NumberOfSections ( 重要 )第二個成員NumberOfSections表示當前PE文件中節的數量，也就是節表中有幾個結構體值一定要大於0，且當定義的節區數量與實際節區不同時，將發生運行錯誤。\n成員 TimeDateStamp第三個成員TimeDateStamp表示編譯器編譯的時候插入的時間戳，與文件屬性裡面的創建時間和修改時間是無關的\n成員 PointerToSymbolTable &amp; NumberOfSymbols第四、第五個成員是調試相關的，我們暫時不用去了解\n成員 SizeOfOptionalHeader ( 重要 )第六個成員SizeOfOptionalHeader表示擴展PE頭的大小，默認情況下32位PE文件對應值位0xE0，64位PE文件對應值為0xF0\n成員 Characteristics ( 重要 )WORD Characteristics2 BYTE =&gt; 16 位第七個成員Characteristics用來記錄當前PE文件的一些屬性，該成員是16位（2字節）大小，其每一數據位對應的屬性如下所示\n\n\n\n\n數據位\n常量符號\nCharacteristics 值\n為 1 時 的意義\n\n\n\n\n0\nIMAGE_FILE_RELOCS-STRIPPED\n0x0001\n文件中不存在重定位資訊\n\n\n1\nIMAGE_FILE_EXECUTABLE_IMAGE\n0x0002\n文件是可執行的\n\n\n2\nIMAGE_FILE_LINE_NUMS_STRIPPED\n0x0004\n不存在行資訊\n\n\n3\nIMAGE_FILE_LOCAL_SYMS_STRIPPED\n0x0008\n不存在符號資訊\n\n\n4\nIMAGE_FILE_AGGRESSIVE_WS_TRIM\n0x0010\n調整工作集\n\n\n5\nIMAGE_FILE_LARGE_ADDRESS_AWARE\n0x0020\n應用程式可處理大於 2GB 的位址 (表示當前程式為 64 位元) (32 位元有 4GB 空間，內核佔 2 GB，應用程式佔&lt;= 2GB)\n\n\n6\n\n\n此標誌保留\n\n\n7\nIMAGE_FILE_BYTES_REVERSED_LO\n0x0080\n小尾方式\n\n\n8\nIMAGE_FILE_32BIT_MACHINE\n0x0100\n只在 32 位元平台上執行\n\n\n9\nIMAGE_FILE_DEBUG_STRIPPED\n0x0200\n不包含除錯資訊\n\n\n10\nIMAGE_FILE_REMOVABLE_RUN_FROM_SWAP\n0x0400\n不能從可移動盤執行\n\n\n11\nIMAGE_FILE_NET_RUN_FROM_SWAP\n0x0800\n不能從網路執行\n\n\n12\nIMAGE_FILE_SYSTEM\n0x1000\n系統檔案(如驅動程式)，不能直接執行\n\n\n13\nIMAGE_FILE_DLL\n0x2000\n這是一個 DLL 文件\n\n\n14\nIMAGE_FILE_UP_SYSTEM_ONLY\n0x4000\n文件不能在多處理器電腦上執行\n\n\n15\nIMAGE_FILE_BYTES_REVERSED_HI\n0x8000\n大尾方式\n\n\n\n\n以 010F 為例010F =&gt; 0000 0001 0000 1111=&gt; 第 8、3、2、1、0 位\nOptional Header這個結構是整個PE文件中佔重要地位，記錄的PE文件的代碼執行入口、運行平台、堆棧屬性等等信息，絕對不能沒有\n\n123456789101112131415161718192021222324252627282930313233typedef struct _IMAGE_OPTIONAL_HEADER &#123;    WORD    Magic; // PE32：10B PE32+：20B    BYTE    MajorLinkerVersion; // 链接器版本号    BYTE    MinorLinkerVersion; // 链接器版本号    DWORD   SizeOfCode; // 所有代码节的总和（文件对齐后的大小），编译器填的（没用）    DWORD   SizeOfInitializedData; // 包含所有已经初始化数据的节的总大小（文件对齐后的大小），编译器填的（没用）    DWORD   SizeOfUninitializedData; // 包含未初始化数据的节的总大小（文件对齐后的大小），编译器填的（没用）    DWORD   AddressOfEntryPoint; // 程序入口    DWORD   BaseOfCode; // 代码开始的基址，编译器填的（没用）    DWORD   BaseOfData; // 数据开始的基址，编译器填的（没用）    DWORD   ImageBase; // 内存镜像基址    DWORD   SectionAlignment; // 内存对齐    DWORD   FileAlignment; // 文件对齐    WORD    MajorOperatingSystemVersion; // 标识操作系统版本号，主版本号    WORD    MinorOperatingSystemVersion; // 标识操作系统版本号，次版本号    WORD    MajorImageVersion; // PE文件自身的版本号     WORD    MinorImageVersion; // PE文件自身的版本号    WORD    MajorSubsystemVersion; // 运行所需子系统版本号    WORD    MinorSubsystemVersion; // 运行所需子系统版本号    DWORD   Win32VersionValue; // 子系统版本的值，必须为0    DWORD   SizeOfImage; // 内存中整个PE文件的映射的尺寸    DWORD   SizeOfHeaders; // 所有头加节表按照文件对齐后的大小，否则加载会出错    DWORD   CheckSum; // 校验和    WORD    Subsystem; // 子系统，驱动程序(1)、图形界面(2) 、控制台/DLL(3)    WORD    DllCharacteristics; // 文件特性    DWORD   SizeOfStackReserve; // 初始化时保留的栈大小     DWORD   SizeOfStackCommit; // 初始化时实际提交的大小     DWORD   SizeOfHeapReserve; // 初始化时保留的堆大小    DWORD   SizeOfHeapCommit; // 初始化时实践提交的大小     DWORD   LoaderFlags; // 调试相关    DWORD   NumberOfRvaAndSizes; // 目录项数目    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; // 表，结构体数组&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;\n擴展PE頭的成員有很多，但我們不需要每個都記住，大概的了解一下即可，重點關注如下這幾個成員\n成員 Magic ( 重要 )成員Magic表示當前PE文件是32位還是64位，32位時該值對應0x10B，64位時該值對應0x20B\n成員 AddressOfEntryPoint ( 重要 )成員AddressOfEntryPoint表示當前程序入口的地址，這個成員要與成員ImageBase相加才能得出真正的入口地址，成員ImageBase用來表示內存鏡像基址，也就是PE文件在內存中按內存對齊展開後的首地址，我們可以在實際PE文件中看下，如下圖所示就是PE文件靜態狀態下的兩個成員值，AddressOfEntryPoint為0x739D，ImageBase為0x1000000，那麼最終的程序在內存中的入口地址就是0x100739D\n\n成員 ImageBase ( 重要 )==成員 SectionAlignment &amp; FileAlignment== 須改 ( 重要 )FileAlignment：指定了節區塊在磁盤文件中的最小單位\nSectionAlignment：指定了節區在內存中的最小單位\nFileAlignment和SectionAlignment的作用就是我們在本文“文件對齊/內存對齊”中講到的，節區與節區之間的間隔，之所以會有間隔就是因為PE文件的節區在硬盤中和在內存中的大小不一致導致的。一個文件的FileAlignment和SectionAlignment的值可能相同或不同。PE文件在磁盤或內存中時，節區大小一定是FileAlignment或SectionAlignment值的整數倍。\n成員 SizeOfImage ( 重要 )成員SizeOfImage表示在內存中整個PE文件映射的大小，可比實際的值大（內存對齊之後的大小，也就表示必須是SectionAlignment的整數倍）\n成員 SizeOfHeaders ( 重要 )該成員用來表示DOS頭、PE頭與節表加起來按照文件對齊以後的大小。這個真正的大小實際上取決於另外一個成員FileAlignment，SizeOfHeaders存儲的數值一定是FileAlignment的整數倍，默認情況下該成員的值為0x200\n假設當前DOS頭、PE頭與節表加起來的寬度為302，而成員FileAlignment的值為200，這時候成員SizeOfHeaders的值按FileAlignment的值進行文件對齊就應該是400，而之所以需要文件對齊是為了提高執行效率，這是一個犧牲空間換時間的一種策略，我們可以在當前PE文件中查看這兩個成員\n\n這兩個成員剛好與我們假設的值是一樣的，所以這裡DOS頭、PE頭與節表加起來按照文件對齊以後的大小就是400，但這樣確實比實際大小要多出一些空間，這些空間默認會用0x00填充，但也有可能這些空間會被編譯器插入一些信息，接著在400地址之後的就是節數據了。\n成員 CheckSum ( 重要 )成員CheckSum表示校驗和，是用來判斷文件是否被修改的，它的計算方法就是文件的兩個字節與兩個字節相加，最終的值（不考慮溢出情況）就是校驗和\n成員 Subsystem ( 重要 )Subsystem值用來區分系統驅動文件（.sys）與普通的可執行文件（.exe、* .dll），可以有如下值如下\n123456789101112131415#define IMAGE_SUBSYSTEM_UNKNOWN                  0   // Unknown subsystem.#define IMAGE_SUBSYSTEM_NATIVE                   1   // Image doesn&#x27;t require a subsystem.#define IMAGE_SUBSYSTEM_WINDOWS_GUI              2   // Image runs in the Windows GUI subsystem.#define IMAGE_SUBSYSTEM_WINDOWS_CUI              3   // Image runs in the Windows character subsystem.#define IMAGE_SUBSYSTEM_OS2_CUI                  5   // image runs in the OS/2 character subsystem.#define IMAGE_SUBSYSTEM_POSIX_CUI                7   // image runs in the Posix character subsystem.#define IMAGE_SUBSYSTEM_NATIVE_WINDOWS           8   // image is a native Win9x driver.#define IMAGE_SUBSYSTEM_WINDOWS_CE_GUI           9   // Image runs in the Windows CE subsystem.#define IMAGE_SUBSYSTEM_EFI_APPLICATION          10  //#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER  11  //#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER       12  //#define IMAGE_SUBSYSTEM_EFI_ROM                  13#define IMAGE_SUBSYSTEM_XBOX                     14#define IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION 16#define IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG        17\n成員 NumberOfRvaAndSizes ( 重要 ) 用來指定DataDirectory（IMAGE_OPTIONAL_HEADER32結構體最後一個成員）數組的個數。雖然結構體中明確定義了數組個數為IMAGE_NUMBEROF_DIRECTORY_ENTRIES(16個)，但是PE裝載器用過查看NumberOfRvaAndSizes值來識別數組大小，換言之，數組大小也可能不是16。\nDLLCharaqcteristics它用來表示PE文件的特性，但不要被名字所迷惑，它不是針對DLL文件的；它的數據寬度是16位（4字節），其每一數據位對應的屬性如下所示\n\n\n\n\n數據位\n常量符號\n為 1 時 的含意\n\n\n\n\n0\n\n保留，必須為 0\n\n\n1\n\n保留，必須為 0\n\n\n2\n\n保留，必須為 0\n\n\n3\n\n保留，必須為 0\n\n\n6\nIMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE\nDLL 可以在加載時被重定位\n\n\n7\nIMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY\n強制代碼實施完整性驗證\n\n\n8\nIMAGE_DLLCHARACTERISTICS_NX_COMPAT\n該映像兼容 DEP\n\n\n9\nIMAGE_DLLCHARACTERISTICS_NO_ISOLATION\n可以隔離，但並不隔離此映像\n\n\n10\nIMAGE_DLLCHARACTERISTICS_NO_SEH\n映像不使用 SEH (第10章)\n\n\n11\nIMAGE_DLLCHARACTERISTICS_NO_BIND\n不綁定映像\n\n\n12\n\n保留，必須為 0\n\n\n13\nIMAGE_DLLCHARACTERISTICS_WDM_DRIVER\n該映像為一個 WDM driver\n\n\n14\n\n保留，必須為 0\n\n\n15\nIMAGE_DLLCHARACTERISTICS_TERMIVAL_SERVER AWARE\n可用於終端服務器\n\n\n\n\n成員 DataDirectory ( 重要 )擴展PE頭之所以數據寬度較大，是因為其有一個成員是結構體數組這個成員的寬度就是16個IMAGE_DATA_DIRECTORY結構體的寬度。\n12345#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16  typedef struct _IMAGE_DATA_DIRECTORY &#123;   DWORD VirtualAddress; //RVA   DWORD Size;   //大小  &#125; IMAGE_DATA_DIRECTORY,  *PIMAGE_DATA_DIRECTORY;\n123456789101112131415161718192021222324252627282930313233#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptorDataDirectory[0] = IMAGE_DIRECTORY_ENTRY_EXPORT             // Export DirectoryDataDirectory[1] = IMAGE_DIRECTORY_ENTRY_IMPORT             // Import DirectoryDataDirectory[2] = IMAGE_DIRECTORY_ENTRY_RESOURCE           // Resource DirectoryDataDirectory[3] = IMAGE_DIRECTORY_ENTRY_EXCEPTION          // Exception DirectoryDataDirectory[4] = IMAGE_DIRECTORY_ENTRY_SECURITY           // Security DirectoryDataDirectory[5] = IMAGE_DIRECTORY_ENTRY_BASERELOC          // Base Relocation TableDataDirectory[6] = IMAGE_DIRECTORY_ENTRY_DEBUG              // Debug Directory//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT          // (X86 usage)DataDirectory[7] = IMAGE_DIRECTORY_ENTRY_ARCHITECTURE       // Architecture Specific DataDataDirectory[8] = IMAGE_DIRECTORY_ENTRY_GLOBALPTR          // RVA of GPDataDirectory[9] = IMAGE_DIRECTORY_ENTRY_TLS                // TLS DirectoryDataDirectory[10] = IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG       // Load Configuration DirectoryDataDirectory[11] = IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT      // Bound Import Directory in headersDataDirectory[12] = IMAGE_DIRECTORY_ENTRY_IAT               // Import Address TableDataDirectory[13] = IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT      // Delay Load Import DescriptorsDataDirectory[14] = IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR    // COM Runtime descriptor\nSection Header節表很重要，其決定節數據的相關屬性，而節數據是我們真正存儲數據的地方，其數量和節表是對應的。\n節表就是N個IMAGE_SECTION_HEADER結構體組成的，該結構體數據寬度是40字節\n該結構體的數量在PE文件頭的NumberOfSections指定。\n12345678910111213141516#define IMAGE_SIZEOF_SHORT_NAME 8typedef struct _IMAGE_SECTION_HEADER &#123;    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]; // ASCII字符串（节名），可自定义，只截取8个字节，可以8个字节都是名字    union &#123; // Misc，双字，是该节在没有对齐前的真实尺寸，该值可以不准确        DWORD   PhysicalAddress; // 真实宽度，这两个值是一个联合结构，可以使用其中的任何一个        DWORD   VirtualSize; // 一般是取后一个    &#125; Misc;\t\t\t\t\t    DWORD   VirtualAddress; // 在内存中的偏移地址，加上ImageBase才是在内存中的真正地址    DWORD   SizeOfRawData; // 节在文件中对齐后的尺寸    DWORD   PointerToRawData; // 节区在文件中的偏移    DWORD   PointerToRelocations; // 调试相关    DWORD   PointerToLinenumbers; // 调试相关     WORD    NumberOfRelocations; // 调试相关     WORD    NumberOfLinenumbers; // 调试相关     DWORD   Characteristics; // 节的属性&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;\n我們可以在該PE文件中看一下有多少個IMAGE_SECTION_HEADER結構體，如下圖用不同顏色標記的就是每個節，其實通過編輯器右邊的內容你就可以大致知道每個節的表示什麼類型了\n\n\n.text  :代碼節(VC) Contains all executable code\n\n.code  : 代碼節(VB/Delphi) Contains imported data such as dll addresses\n\n.data  : 數據節(一般存放已初始化的全局變量，靜態變量) Contains initialized data like global variables ans string literals\n\n.rdata  : 只讀數據節(一般存放只讀數據，如常量字符串，C++虛表) .idata : 輸入數據表(一般用來存放IAT和導入表) Contains any exported data\n\n.bss  : 通常是指用來存放程序中未初始化的全局變量、靜態變量.textbss : 節中同時包含代碼和未初始化全局變量、靜態變量 Contains un-initialized data\n\n.rsrc  : 資源節 Contains all module resources\n\n.reloc  : 重定位表 Contains relocation data for the OS loader\n\n\n代碼中的註釋可以大致了解到每個成員的作用，其中有2個成員來描述節的大小，分別是沒有對齊前的真實尺寸和對齊後的寬度，這時候會出現一種情況就是對齊前的真實尺寸大於對齊後的寬度，這就是存在全局變量沒有賦予初始值導致的，在文件存儲中全局變量沒有賦予初始值也就不佔空間，但是在內存中是必須要賦予初始值的，這時候寬度就大了一些，所以在內存中節是誰大就按照誰去展開。\n\n與其他結構體一樣，PE節也有屬性，這就是成員Characteristics，其數據寬度是16位（4字節），其每一數據位對應的屬性如下所示\n\n更多可以參考如下\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//// Section characteristics.////      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved. #define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data. #define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.//                                           0x00002000  // Reserved.//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000#define IMAGE_SCN_NO_DEFER_SPEC_EXC          0x00004000  // Reset speculative exceptions handling bits in the TLB entries for this section.#define IMAGE_SCN_GPREL                      0x00008000  // Section content can be accessed relative to GP#define IMAGE_SCN_MEM_FARDATA                0x00008000//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000#define IMAGE_SCN_MEM_PURGEABLE              0x00020000#define IMAGE_SCN_MEM_16BIT                  0x00020000#define IMAGE_SCN_MEM_LOCKED                 0x00040000#define IMAGE_SCN_MEM_PRELOAD                0x00080000 #define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //#define IMAGE_SCN_ALIGN_128BYTES             0x00800000  //#define IMAGE_SCN_ALIGN_256BYTES             0x00900000  //#define IMAGE_SCN_ALIGN_512BYTES             0x00A00000  //#define IMAGE_SCN_ALIGN_1024BYTES            0x00B00000  //#define IMAGE_SCN_ALIGN_2048BYTES            0x00C00000  //#define IMAGE_SCN_ALIGN_4096BYTES            0x00D00000  //#define IMAGE_SCN_ALIGN_8192BYTES            0x00E00000  //// Unused                                    0x00F00000 #define IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000  // Section contains extended relocations.#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.\nRVA 與 FOA 的轉換PE空白區添加代碼EAT ( Export Address Table, 導出表 )12345678910111213typedef struct _IMAGE_EXPORT_DIRECTORY &#123;    DWORD   Characteristics; // 未使用    DWORD   TimeDateStamp; // 时间戳，表示当前PE文件（DLL）编译时的时间    WORD    MajorVersion; // 未使用    WORD    MinorVersion; // 未使用    DWORD   Name; // 当前导出表文件名字符串的地址    DWORD   Base; // 导出函数起始序号    DWORD   NumberOfFunctions; // 所有导出函数的个数    DWORD   NumberOfNames; // 以函数名字导出的函数个数    DWORD   AddressOfFunctions;// RVA，导出函数地址表    DWORD   AddressOfNames; // 导出函数名称表RVA    DWORD   AddressOfNameOrdinals; // 导出函数序号表RVA&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;\nIAT ( Import Address Table, 導入位址表 )PE文件所依賴的模塊以及涉及到依賴模塊中的具體函數都存儲在導入表中，我們可以在PE格式圖的擴展PE頭最後一個成員結構體數組中的第二個結構體找到導出表相關的信息，它有2個成員，一個表示導入表的地址，一個表示導入表的大小\n\n導入表與導出表不同，導出表只有一張，而導入表有很多張，每一張表對應著不同的依賴模塊，導入表的結構如下，它一共有20字節\n12345678910typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;    union &#123;        DWORD   Characteristics;        DWORD   OriginalFirstThunk; // RVA，指向IMAGE_THUNK_DATA结构数组    &#125;;    DWORD   TimeDateStamp; // 时间戳    DWORD   ForwarderChain;    DWORD   Name; // RVA，表示依赖模块名字的地址，这是一串字符串    DWORD   FirstThunk; // RVA，指向IMAGE_THUNK_DATA结构数组&#125; IMAGE_IMPORT_DESCRIPTOR;\n重定位表在PE中最重要的三張表就是導出、導入和重定位表，本章來了解一下重定位表。\n重定位表是什麼？假設某一PE文件使用了一些模塊，這些模塊都有自己的ImageBase（在內存中開始的地址），但是實際上在內存中模塊的ImageBase被別人佔用了，這時候模塊就需要偏移，換一個新的內存地址去展開，假設在這模塊中有很多已經寫好了地址的硬編碼（但凡涉及到直接尋址的指令都需要進行重定位處理），當換了地址之後就找不到了，甚至會出現安全隱患，所以硬編碼的地址是需要隨著偏移而去修改的，這時候就需要一張表去記錄需要修正的位置，便於去根據對應偏移修正，這張表我們就稱之為重定位表；一般來說，EXE文件是沒有重定位表的，因為它不會提供函數給其他人用（導出表），所以運行時它理應是第一個載入內存中的，而DLL之類的PE文件則一定是需要重定位表的，因為它並不一定會加載在ImageBase上。\n重定位表的位置信息與導入、導出表一樣，在擴展PE頭的最後一個成員中的第6個結構體，結構體的成員與導入、導出表一樣，分別表示重定位表的起始位置和大小\n\n重定位表中有一個結構體，它一共有8字節\n12345typedef struct _IMAGE_BASE_RELOCATION &#123;                         DWORD   VirtualAddress; // RVA    DWORD   SizeOfBlock;&#125; IMAGE_BASE_RELOCATION;typedef IMAGE_BASE_RELOCATION ，* PIMAGE_BASE_RELOCATION;","slug":"reverse_逆向工程核心原理_第 13 章_PE 文件格式","date":"2022-07-27T20:31:25.000Z","categories_index":"","tags_index":"reverse","author_index":"Chico"},{"id":"235b11c396ac216898357dcad8a5a1c6","title":"20 個實用的前端開發參考資訊整理","content":"\n\n\n\n\n\n\n\n\n\n\n\n此篇為各筆記之整理，非原創內容，資料來源可見下方連結與文後參考資料\n原文連結： 20 Useful Docs and Guides for Front-End Developers\n看到上面的文章收集了許多前端開發參考資訊，覺得非常實用，故將重點整理如下：\n\nCSS Vocabulary 可以瞭解 CSS 中的名詞實際對應的部份。\nLiquidapsive 介紹 Responsive / Adaptive / Liquid / Static 四種排版方式及其差異，網站本身即為實例。\nSuperhero.js 這個網站收集非常多有關 JavaScript 的文件、簡報或影片！\nHowToCoffeeScript.com 把許多常用的 CoffeeScript 技巧整理成速查表。\nThe HTML Landscape 介紹 WHATWG / W3C’s HTML5.0 / W3C’s HTML5.1 三種 HTML 規格的差異。\nThe Elements of HTML 把 2.0 ~ 5.1 各個版本的 HTML 元素整理出來了，非常詳盡！\nJavaScript Equality Table 用二維表的形式來呈現 JavaScript 的 == / === / if 是如何比對值。\nWeb Accessibility Checklist 列出專案如果要達成無障礙所需要注意的項目。\nStatic Web Apps — A Field Guide 列出了常見的 Web Apps 開發注意事項或解決方案。\nLearn regular expressions in about 55 minutes 列出正規表達式學習的重點，並輔以範例供參考。\nOpen Web CSS Reference 這個網站整理了 CSS 屬性與其進階特色的 W3C 連結。\nCSS Values 輸入 CSS 屬性後，可以看到它的屬性值參考、瀏覽器相容性及相關連結。\nES6features 整理了 ECMAScript 6 的特色。\nRelevant Spec Links 列出許多有關前端技術的規格連結。\nOverAPI.com 幾乎把所有有關網站開發的語言或工具所使用的 API 都整理成速查表了。\nJavaScript: The Right Way 整理了所有有關 JavaScript 的開發相關資訊。\nThe HTML5 JavaScript API Index 整理了 HTML5 在 JavaScript 的所有 API 。\nZeal 類似 Mac 上的 Dash 參考文件整合軟體，是給 Linux / Windows 使用者。\nThe Ultimate Flexbox Cheat Sheet 整理有關 CSS FlexBox 的教學。\njsCode 可以自訂並產生 JavaScript Coding Guideline 的服務。\n\n參考資料\n20 個實用的前端開發參考資訊整理\n\n","slug":"20-個實用的前端開發參考資訊整理","date":"2022-09-20T08:47:43.000Z","categories_index":"","tags_index":"","author_index":"Chico"},{"id":"aa3ac17bb7565bcd4445c7f0c81d5147","title":"Software Engineering - The Soft Parts","content":"\n\n\n\n\n\n\n\n\n\n\n此篇為各筆記之整理，非原創內容，資料來源可見下方連結與文後參考資料\n本文翻譯自 Addy Osmani(@addyosmani) 部落格的 「Software Engineering - The Soft Parts」 一文，翻譯已取得作者授權。 分享或轉貼本文章請註明此文章連結以及原作者的文章連結。\n\n今天，我將分享在 Google Chrome 第一個十年所學到的一些軟體工程師的「軟技能」，我是一位 Senior Staff Engineering Manager。在我的十週年，我想要反思一些伴隨在我身邊的課題。我希望這些經驗對妳的職涯有幫助。\n成為一個好的工程師就收集經驗。在每個 project 中，即便很小，都是一個機會去加入新的技術和工具到妳的技能樹（toolbox）。當妳在一個 project 中學到的技術和在另一個 project 中學到的工具，結合起來解決問題時，就會帶來更大的價值。這一切都會增加。\n\n學習新事物以下幾點應該能幫助大部分的 junior 或 mid-career 開發者向前邁進，應應不斷變化的技術，遵循軟體工程典範（paradigm）的標準流程和發現新的最佳實踐（best practice）的同時建立複雜的系統。當妳可以的時候，採用 First Principle。學習去拆解（break down）問題成更小的問題是生活中重要的技能之一。\n精通技術的掌握意味著交付的價值與工作時間的高水準。這意味著妳可以分辨出那些能增加價值的任務，並且幫助妳的團隊將精力集中在這個方向上。這也代表著妳知道如何避面那些不能為團隊/公司提供價值的工作 - 優秀的工程師甚至可以引導整個團隊遠離那些不是那麼有用的工作。\n我經常被問到： 「我怎麼知道我是否充分利用了我的時間？」。 幾乎總是會有一些任務可以讓妳「感到」忙碌。真正的訣竅是確保妳在正確的事情工作上。如果妳想要移山，就把注意力集中在能夠移動的任務上，即使這個移動是很小的。\n妳可以問自己一些問題：\n\n我的目標是什麼？我所專注的任務是否與我的目標相同？\n有沒有什麼事我可以用不同的方式做或者是可以做得過更好的地方？\n\n即使是問自己這樣的問題，也會有超乎尋常的力量。\n\n批判性的思考並提出合理的論點批判性思考是使用認知能力去獨立思考以做出深思熟慮決定的能力。投資這項技巧，來提高妳思維清晰度。做為一位工程師，我們有時候急於去立即處理問題，因此感覺就像我們正在取得進展，或者看起來我們正在對利益相關者（stakeholder）做出回應。如果我們沒有充分考慮原因和後果，這可能會帶來風險。換個方式，批判性思考是有目的性的思考並形成自己的結論。這個目標導向（goal-directed）的思考可以幫助妳專注在根本問題，避免因為沒有牢記因果關係而引起的未來問題。\n概括來說，我喜歡根據批判性思考去問一些問題：\n\n我們怎麼知道我們正在解決正確的問題？\n我們怎麼知道我們用正確的方式在解決問題？（例如：考慮到我們對問題和限制因素的理解，平衡嚴格性和效率）\n如果我們無法得知我們問題的來源，我們要如何確定根本原因？\n我們如何將關鍵問題分解為可以進一步分析的更小問題？\n一旦我們有了一個或多個假設，我們如何組織工作來評估它們？\n如果我們受到限制（時間壓力）而又不過度損害我們對問題的分析嚴謹性，我們可以採取哪些捷徑？\n證據是否充分支持結論？\n我們怎麼知道什麼時候完成？什麼時候解決方案「足夠好」？\n我如何向所有利益相關者（stakeholder）清晰、合乎邏輯的傳達解決方案？\n\n我發現這些問題通常很有幫助。有時我們會解決一個問題的症狀，卻發現還有其他症狀跟著浮出。在其她時候，我們可能會很快發佈一個解決方案，但會產生更多問題。帶著批判性思考的角度，我們可能會挑戰假設，仔細研究風險/效益，找出互相矛盾的證據，評估可信度，並找出更多資料來建立我們做正確事情的信心。\n例如，我見過工程師犯的一個常見錯誤是假設相關性意味著因果關係（就是僅僅因為兩件事相關，但並不代表前者問題導致後者的問題）。一個批判性的思考者可能會反駁這樣的假設，問我們為什麼相信它們是正確的。\n批判性思考者：\n\n提出有意識的問題，清晰而準確地提出問題\n收集和評估相關的訊息，驗證它們可能會如何回答問題\n得到合理的結論和解決方案，根據相關規範和標準進行測試\n在不同的思想體系中進行開放性思考，必要時認識和評估其假設、影響和實際後果\n在找出複雜問題的解決方案時，與他人進行有效的溝通\n\n注意：批判性思考包含「軟技能」和「硬技能」兩個面向，也包含在這篇文章中。\n\n建立強大的基礎掌握基本原理並且反覆應用，以獲得新的技能。學習基礎知識的長期價值在於它們是可以轉移的。短期而言，它們能幫助妳做出更好的決定，並讓妳的程式碼更有效率。\n\n可轉移的技能可轉移的技能是妳可以從這個 project 帶到另一個 project。讓我們從基礎面來談談它們。\n基本原理是所有任何軟體工程師的職業基礎。它們有兩個層面 - 宏觀（marco）與微觀（micro）。宏觀的層面是軟體工程的核心，微觀層面是實現（例如：tech stack、libraries、frameworks 等）。\n在宏觀層面，妳學習 programming 概念在很大程度上可以轉移，而與語言本身無關。語法可能有些不同，但核心概念是相同的。這可以包含像是：資料結構（array、object、module、hash）、演算法（searching、sorting）、架構（design pattern、state management）甚至是效能最佳化（例如：eager vs lazy evaluation、memoization、caching、lazy-loading 等）。這些概念妳會經常的使用，了解它們後有很大的價值。\n在微觀層面，妳要學習這些概念的實現。這包含像是：妳使用的語言（JavaScript、Python、Ruby 等等），妳使用的 framework（例如：React、Angular、Vue 等等），使用的後端（例如：Django、Rails 等等），妳使用的 tech stack（例如：Google App Engine、Google Clound Platform 等等）。其中涉及的細節對於有效的專業知識可能很有價值，但並不總是可以轉移的。\n透過學習基礎知識，妳可以獲得技能和工具，然後忽略基礎知識並成長。務實地說，沒有人在職業生涯開始就有時間學習所有東西。 有一點是，妳不應該過度關注基礎知識，應該學習建立真實世界應用程式所需要的東西。就是「邊做邊學」的方法。\n\n效率了解基礎原理可以幫助妳寫出更有效率的程式碼。這包括像是時間複雜度（執行妳程式碼的時間）、記憶體使用以及效能和可維護性之間權衡等概念。這些概念可以讓妳在建構任何合理的大型應用程式時作出權衡，這對妳很有幫助。速度對於現代應用程式來說往往是很重要的，而且往往會以明顯的方式影響終端使用者的體驗。\n\n做出更好的決策擁有了解宏觀和微觀的基礎了解可以幫助妳做出更好的決策。妳可以使用已經獲得的知識，根據任何 project 的目標和限制，對於使用哪些技術以及避免哪些技術做出更好的決定。這可以幫助妳避免錯誤的技術或是工具來完成工作的陷阱。\n\n\n\n\n\n\n\n\n\n“You haven’t mastered a tool until you understand when it should not be used.” - @kelseyhightower\n軟體工程師涉及考慮許多不同的層面 - 核心語言、實作、基礎設施（infrastructure）、工具以及人們。只有對這些層面有一個表面上的了解，絕對可以讓妳的建立速度更快。但真正了解基礎知識（包括 O(n) 時間複雜度）可以幫助妳走得更遠，特別是當語言和框架的格局隨著時間推移而變化時。\n相關閱讀：\n\nThe value of fundamentals in Software Engineering\nWhy learning the fundamentals matters\nLearn the fundamentals of a good developer mindset\n\n\n專注在使用者，剩下的就會跟上從使用者體驗開始，然後再回技術上。Steve Jobs 曾經有一句名言：「妳必須從客戶的體驗開始著手，然後再回到技術上。妳不能先從技術出發，然後再嘗試找出妳的銷售對象」。\n這句引言伴隨著我，因為作為工程師，從想要使用特定解決方案的地方開始太容易了 - 無論是由於受歡迎的程度、開發者體驗或者是個人的偏好 - 並嘗試找到一個方式來合理的使用它們。相反的，我們應該專注於我們為誰而建立，她們遇到什麼問題，以及目前的可用的選項為何不足。\n\n好的使用者體驗來自於兩種觀點的結合 - 客戶和技術。向人們展示妳認為她們想要什麼，並留意她們說了些什麼。當然，這個問題的空間有巨大的細微差別 - 什麼樣的工程選擇能讓妳在移動裝置上提供良好的體驗？什麼樣的選擇會影響工程開發的速度？或規模？或是招募？最終，我們受益於對客戶的不懈關注，然後在我們必須處理的限制條件下探索，使我們能夠滿足她們需求的方法，從而使我們受益。\n最好的軟體是由對使用者具備同理心的工程師建構的。商業的成功是取決於客戶的滿意度，這通常轉化為軟體的使用者體驗。了解最終使用者如何體驗產品或服務。確保妳的解決方案不會妨礙她們高效完成工作的能力。如果妳的職位允許妳直接和使用者互動，請嘗試更好的去理解她們需要什麼以及痛點在哪裡。\n\n提升妳的技能選擇妳適合的技術，而不是目前最受歡迎的。使用「無聊」的技術（經過嘗試與測試的技術）vs. 炒作的技術是可以的。語言、框架、函式庫經常的演變。選擇有助於交付出色的最終產品內容。當開始一個新 project 時，從「無聊」的技術（但很好理解）開始，然候有意地決定從中選擇最佳的工具來解決問題。\n在挑選新技能來學習或使用時，不要害怕選擇一些無聊或是不是這麼新的東西。當涉及到技術時，無論是語言、框架還是函式庫和工具，FOMO（Fear of missing out） 可能都不會有生產力。雖然知道用什麼很重要，妳的主要目標是交付一個很棒的最終產品。請不要追逐最新和最耀眼的技術，除非妳認為它們可以為妳解決方案帶來價值。與此同時，不要因為某件事情沒有被充分討論，而迴避它。\n利用新專案的優勢去學習新技術。與此同時，個人以及黑客松 project 是一個學習新技術的好機會。我們當中，許多人很少有機會開始全新的事物；相對於在一個既有的 codebase 上工作，許多決定已經被做出。這樣的 project 是一種低風險方式來研究新技術、評估其優勢和劣勢（小規模），並累積一些對於妳未來有價值的第一手知識。\n保持好奇心並且不斷學習寫下妳學到的東西。這促使妳去更好的了解這個主題。有時候，妳的知識差距只有在妳嘗試對別人解釋時才會變得更加清楚。如果沒有人閱讀妳寫的東西也沒關係。只要為妳自己而做，就能獲得更多。學習應該是一個持續的過程 - 那些聲稱對某項技術暸若指掌的人往往不是專家。真正的專家精通技術，但意識到總是有學習和改進的地方。好奇心驅使學習 —— 所以如果妳好奇一個新的 framework，google 搜尋它、閱讀文件、嘗試教學文件、閱讀原始碼。學習不需要在教室才可以發生。它可以在任何地點、時間發生。每天花半小時去閱讀 textbook 的一個章節、聽聽技術 Podcast、閱讀開發技術部落格或者是學習一個新的程式語言。\n當 Leaders 不知道某事情時，承認這一點是很強大的。有了這種信心，就會降低對 senior engineer 必須了解一切的期望。妳絕對不需要擁有所有的答案。但能夠承認妳是人，並致力於找出如何與妳的團隊一起解決問題才是重要的。\nLeaders 在犯錯時也會承認。教導妳的團隊如何謙虛地處理錯誤，並渴望望學習與改進，這很重要。現實世界並不完美，像妳的團隊展現它的不完美是完全可以的，讓她們做好準備。\n成為一個 caretaker，而不是一個 owner在 open-source 的早期階段，像 owner 那樣思考是很正常的。妳經常直接證明出價值、開發 features、回答 issues 和宣傳。這對於獲得採用可能有用，但當人員變動或妳自己的時間有限時，這可能不是擴展 preojct 的最佳方式。\n在最初的 crunch 後，考慮轉變角色的另一種方式是成為 caretaker，而不是 owner。一個 caretaker 可能會專注於擴大自己。這可以通過與其它 maintainers、contributors 和 community 盡可能地分享知識來實現（透過設計文件、程式碼註釋，以及其它記錄的最佳實踐）。它還有助於增加有足夠背景的 reviewers，以便在妳不再參與時做出正確的決定。\n這通常是 project 需要在將來多年後可以持續發展的原因。\n\n技能的深度與廣度考慮成為一個萬事通和一個大師是否適合妳。妳能掌握最棒的技能之一就是學會如何學習。這應該是一個優先事項，而不是指深入特定的程式語言或是 framework。它幫助妳保持好奇心。一旦妳有了這個經驗，妳可能會質疑妳的目標是成為一個專家還是一個萬事通。\n我個人喜歡 T-Shaped engineers 的概念。這些工程師是在一項或是少數幾項技能方面的深度專家（the vertical bar of the T），但她們對建立和執行一個產品所需要的許多其她技能都有基礎的理解（the horizontal bar）。有些團隊喜歡通過一系列不同的專業來輪調團隊成員，來建立更多的 T-Shaped 團隊成員。\n我發現在中大型規模的團隊中，讓在某一個領域擁有專業技能的人以及在必要時為他人填補技能、多功能性和協作能力的人是很有效的。\n\n體驗就是學習在學習一個新語言時，專注於用它建立一些有形的東西，給妳帶來第一手的經驗。如果妳正在學習一個新語言，妳不需記住它所有的語法或是文件才能成為一個好的開發者。更重要的是如何去解決問題。透過撰寫大量的程式碼或是從現有的程式碼中來學習以獲得經驗。結果應該有助於使用該語言撰寫更有效率的程式碼。正如這裡所提到：「軟體的價值不是產生程式碼，而是產生程式碼的人所累積的知識」。在測試新技術時，請不要在 production 中進行實驗。\n\n技術複雜性通用 vs 特定的程式碼為手邊的特定的問題撰寫程式碼，但要嘗試找出妳負擔的起的部分，讓它變得有點通用。通常情況下，我們會嘗試讓程式碼變得通用，而最終做出的是無助於解決問題的程式碼。相反的，專門為這個問題建構，但試圖找出使可以變得更通用的部分，完全消除了我知道我沒有考慮到它，我以後不得不再次重構。\n有幾個通常討論的原則涉及設計複雜性。在 extreme programming 世界中，妳擁有：\n\nYAGNI 或妳不會需要它，它點出程式開發人員在必要之前不應該新增功能。\n做最簡單可行的事情 － 以取得快速的進展，而不是為未來做計畫。\n\n這兩個原則都是在避免過度工程（over-engineering）。然而，這些原則可能會被濫用來建立多種簡單的解決方案，而這些方案卻不能很好的整合。\n在光譜的另一端，妳有抽象)原則，旨在通過 abstraction 和 generalization 可行的情況下，來減少程式碼的重複。我更喜歡在極端抽象和極端簡單之中取得平衡，讓程式碼稍微通用一些。AHA （Avoid hasty abstractions）原則提倡這類的想法。\n\nDeep modules為其他開發者撰寫程式碼解決問題，但是通過清晰的 interface 來公開功能。如果妳是一位 API 設計者或是開發者 - 妳的責任是為其她開發者提供一個簡化複雜後的功能 interface。如果 interface 太複雜以致於難以離解，並且給使用它的程式開發人員帶來成本，那麼目的就失敗了。這個想法體現 Deep Modules 的概念中 - 「最好的 module 帶來最好的效益以及最少的損失。一個 module 的效益就是提供功能，而一個 module 它的成本就是 interface。」\n雖然簡單的 interface 是可以的，但複雜的問題有時候需要複雜的程式來解決它們（這不是一個通用的規則，但通常是這樣）。這種複雜性最好嵌入到程式碼內。當複雜的功能被抽象化時，提供給 end-user 或是 interface 使用者的價值就更高了。\n與使用較少 public/class 實作相同功能的另一個 API 相比，具有多個可見的 function 和包含某些功能的 class 的 API 更複雜且更難搜尋。新 function 和 class 增加了維護程式人員和 library 使用者的 interface 成本。\n\n學習維護 Project在舊的系統處理 legacy code 時，了解哪些程式碼該留下，哪些該移除的區別。任何 senior engineer 都應該努力理解應該留下的程式碼和應該移除的程式碼之間的區別。\n了解該留下的程式碼和應該移除的程式碼之間的區別是很重要的。大型、長期的 production 系統有一些糟糕的程式碼或是有一些沒有充分足夠理由被留下的程式碼。理解為什麼存在的某些東西是健康的（好的理由？壞的理由？）。刪除糟糕的程式碼，保留好的程式碼。\n我在許多公司工作過，許多人認為 legacy 的程式碼是碰不得的，或者是出於一個很好的理由而設計的方式，已經消逝在時間之中。這會導致對於變化的恐懼，妳只是不斷的在薄弱的基礎上增加抽象的東西。\n軟體產業已經到了一個階段，許多 project 都涉及到舊的或是 legacy 系統的 migration 和維護。如果妳發現自己待在這樣的團隊中，請不要沮喪。有很多特定領域的知識，妳可以透過舊的程式碼獲得。雖然 production 中存在較舊的程式碼/驗證可能有充分的理由，但不要假設每一行都是相關的，這是健康的。\n一些軟體工程師對於觸碰在 production 中的程式碼持謹慎的態度，因為她們擔心會引入 bug。因此，她們包括條件，並針對較新的用例重複一些程式碼。這種 workaround 的方式可能會節省時間，隨著時間它會變成維護長期的惡夢。不要認為現有的程式碼是幸運的或是無懈可擊的。可能有一些以前被忽視的 scalability 或 efficiency 方面的問題，妳可以解決。\n\n在一個未開發的 Project 上學習實驗、創新、快速失敗以及更好的解決問題。當妳的任務是從頭開始建立一個系統時，妳的學習旅程是完全不同的。當妳開始迭代原型或是實作功能時，妳會學習到什麼是可行的，什麼是不可行的。敏捷方法（Agile methodology）和快速失敗原則（fail-fast principle）幫助妳用更少的資源提前驗證想法。它們使妳能夠劃分和克服複雜的問題。\n\n完成的定義定義什麼是「完成」是節省時間的，因為它幫助妳估算所需的 effort、開發的計畫以及避免日後不必要的修改。當處理複雜問題時，另一個敏捷原則也很有用，那就是完成的定義達成一致。除了滿足使用者的需求和驗收標準外，還可以包括其她條件像是程式碼審核（code review）、測試（testing）、文件（document）等等。\n\n階段性的推出一個大版本可以分為一系列風險較低且易於理解的發佈。當計劃 large-scale production 系統發佈時，推出計劃與架構、程式碼一樣重要。階段性的發佈與迭代開發有助於妳更好的管理因重大更改而導致的風險。妳也和開發以及測試策略建立發佈策略，以便為複雜的發佈制定 end-to-end 的計畫。\n\n系統化的除錯當除錯時，妳應該盡量系統的、嚴格的解決問題，來解決所有的測試條件。閱讀錯誤訊息（以及 stack trace）。這裡可能有寶貴的資訊，可以幫助妳區隔，以便解決問題。令人驚訝的是，許多工程師在尋求除錯幫助前忽略了錯誤訊息所能提供的 insight。假設妳的機器告訴妳發生了什麼問題，而且可能是正確的，而不是做一些小的編輯和不斷的重新執行程式碼會更快的解決問題。如果妳撰寫了一個拋出異常（throws an exception）的解決方案，但沒有仔細閱讀異常訊息，妳可能只是在浪費時間。通常錯誤（error）和異常訊息（exception message）是一個很大的提示，說明實際上出了什麼問題。\n\n設計文件設計文件的重要性設計文件不是事後的想法，而是軟體工程組成的一部份。設計文件是一個無處不在的工具，它可以幫助妳從需要與妳的系統部分交互的同儕或其她團隊那裡獲得共識。來自他人的回饋可以使妳找出 gap 並完善妳的設計。設計文件還可以對未來加入團隊的工程師提供寶貴的幫助。這可以有助於她們了解問題 space 以及設計解決方案時考慮的權衡（trade-off）和替代方案。設計文件提供一個空間來記錄所有參與設計的人和她們的貢獻，作為文件歷史的一部份。這可以幫助其他人了解誰推動了具體的決定，以及聯繫誰以獲得進一步的闡述。\n文件流程協調對設計文件的審查，並在設計發展過程中與原始文件進行比較，已驗證所有相關的約束條件是否得到解決。雖然一個人可以記錄設計，但實際上設計過程是在一系列的白板會議、隨機的當面討論、slack threads 或是 email/電話討論中發生的。只有在妳把它寫在紙上後，妳才能找出矛盾的承諾，並看看妳討論的不同的部分是否適合在一起。在建立初稿之後，協調審查可以確保所有相關的人都有參與進來。然而，可能發生的事情是，由於沿途發生了一些改變，已實現的設計與文件中的內容已經不一致。\n\n溝通謙虛、溝通明確以及尊重他人。善待他人不需要任何花費，但其影響是無價的。有人可能會說良好的溝通需要花費精力和心思。應該有更多的精力用於同情心。溝通是成為一個有效率、高產出的軟體工程師所需的軟技能或人際關係技能的一個關鍵部分。錯誤的溝通導致不正確的功能、不相容的程式碼或是令然反感的團隊互動。溝通可以幫助人們更好的理解需求以及防止問題變得更糟。\n世界上的人們可能會把軟體工程師想像成是整天寫程式碼的人。然而，為了確保我們的產品對他人有幫助，我們必須使我們的努力與團隊中的其他人以及業務和使用者的期望同步。這使得協作和溝通成為我們工作的關鍵支柱。\nJunior 的開發人員大多數與其他團隊成員、測試工程師以及團隊領導者溝通，分享想法和討論其它的可行性方案。隨著我們的事業發展，為有效完成工作所需的溝通數量也在增加。電子郵件、會議以及公開談話的數量增加。我們必須與 business leaders、managers、stakeholder 以及 team members 溝通。妳的工作越專業，別人不容易理解妳的風險就越大。\n客製化的溝通使用與妳的聽眾相關的語言、概念以及細節水平。無論我們對一個問題或情況的理解程度如何，當我們與他人討論時，我們必須調整我們的語言，使她們能夠迅速掌握與她們有關的內容：\n\n當與商業人交談時，談論妳正在做的事情對商業影響。避免過度使用技術用語。\n當與工程管理部門交談時，要溝通技術影響和挑戰。\n當與決策者溝通時，妳要描述可用的選擇及其影響和風險，而不是選擇如何運作的細節。\n當提供狀態更新時，要注意還有哪些事情發生，以及妳的更新與 project 目標有什麼關係。\n\n同樣的原則也適用於撰寫郵件和向眾人簡報的情況。寫下與接收訊息的人相關的內容。當妳在簡報時，妳可能要為妳的觀點辯護。已深思熟慮的方式來表述問題和回答。衝動的反應通常不利於溝通。\n善良和體貼善良是一種超能力 - 發揮它。平靜、善良以及樂於助人可以幫助妳走得更遠，而不是切斷與別人的關係。對妳團隊中的人好一點，因為有助於使團隊更加強大和成功。對妳團隊以外的人也要友善。對待妳組織內的所有部門（HR、finance、或是 marketing）給予同等的尊重。妳可能不會直接幫助她們。但妳總是可以理解她們的工作，並對她們產生同情。當別人做得好或是獲得讚賞的時候，祝賀，祝賀和讚賞她們。善良是會傳染的。妳曾經善待的人更有可能在未來對任何請求做出回應。\n慷慨的告訴朋友們妳們做得很好。雖然在需要改進的時候給予回饋很重要，但如果事情進展得順利，給予正向的回饋也很關鍵。這有助於妳的團隊知道她們正在做出改變並受到重視。\n說「不」的力量説「不」比過度承諾來得好。我們大多數人都不善於在在涉及更多工作的時候說「不」。要麼是因為她們沒有意識到「不」是一種選擇，要麼是我們喜歡這種挑戰。然而，過度承諾是一種責任，因為它可能導致延誤。讓對方知道妳已經在做什麼，並提出一個合理的估計，說明需要多長的時間，這是尊重的表現。這讓對方有機會考慮她們的選擇 - 詢問他人或延長她們的 timeline。管理階層如果知道這會重大的影響產品的品質，她們不會要求妳在不合理的時間內交付產出。如果妳是一位 senior manager，請授權妳的團隊對壞主意說不。\n\n\n\n\n\n\n\n\n\n「一個資深開發人員（或任何高產出的人）擅長說不。人們會要求妳花更多的時間，而不是妳成抽出時間。妳可以溫柔但堅定的說不，將對方引導至其她地方（delegate），或請對方與妳的 manager 討論是否可以分配更多的時間來幫助她們。」1\n妳不可能取悅所有人 - 在説「yes」 和「no」時要非常注意。與 Leaders 對所有事情說「No」相對應的是對所有事情說「Yes」，卻沒有設定明確的界線。承擔超過以妳目前的資源可以合理執行的範圍，會導致妳和妳的團隊、最終是妳的客戶感到心痛。這一點對領導者來說更為著要，因為其她人會期待妳制定規範，故素她們什麼時候應該說「yes」或是溫柔的駁回。\n接受和尊重承認妳不知道所有事情，並且向她人請教，即使是向後輩。承認妳不知道的事情沒問題的。軟體中最重要的技能之一是能夠找到答案並從中學習。\n作為一名 senior leader，要學會接受身邊的 junior 可能更了解 project 的技術細微差別。當妳不知道的時候，承認是可以的，並且讓 junior engineer 來解釋。她們會因為妳的誠實和對學習的興趣更加的尊重妳，妳也會更好的瞭解情況並為它增加價值。作為一名 junior engineer，妳應該根據前輩們的舒適程度（comfort level），公開或是私下的向 senior 解釋技術概念。\n資訊分享利用 meeting 和 Q&amp;A session 提出正確的問題、交流知識為團隊提供訊息。在一個會議進行時，不要成為唯一說話的人。會議是其他人分享想法或是提供誠實回饋的機會 - 所以要傾聽並為其他的貢獻留出空間。\nJunior engineer 可能會害羞於提出太多問題。如果妳是一個 senior，妳可以透過帶出一些 context 來 prompt 她們提出正確的問題。在回答問題的時候，讓提問的人知道妳很高興她們提出這個問題。\n彈性堅定的捍衛妳的觀點，但也要在每次有新的證據與妳的觀點矛盾時進行反省。傾聽其他意見是溝通的一個關鍵的部分。這一點很重要，因為對一個問題可能有不只一個解決方案。與其執著自己的觀點，不如傾聽並評估其他的選擇。也許她們會提出一個妳已經忽略的面向。Paul Saffo 的 「Strong opinions weakly held」原則告訴我們要堅定的捍衛妳的觀點，但也要在每次有新的證據與妳的觀點矛盾時進行反省。它是一種基於科學正確的方法，不考慮提出想法或意見的人。\n保持記錄在一個非正式的 meeting 後，一封友好的 email 有助於幫助重申討論中的 key points 或是 commitments。純粹的口頭交流的缺點是它會被遺忘或是被記錯。記錄下所有發生的事情，並在相關的討論中得到 sign-off，就可以消除這種風險。如果妳或是其她人已經同意幫助完成一項任務，那麼通過 email 確認 deadline，以確保每個人包含妳的上司都一致的同意。保留這種計畫外工作的記錄，在考核討論中也會有幫助。\n善意的知道什麼時候該保持沈默，並且注意觀察所發生的變化。可能會有這樣的情況：妳不了解一些決策，或是由於技術和商業原因，這些決定不合理。這可能發生在多個團隊（multi-team）討論中。真誠的參與並假設人們不會冒著公開惡意攻擊的風險。可能妳沒有掌握完整的情況，或者是她們有不同的優先事項。提出問題並陳述妳的意見，不要對最後決定感到憤怒或沮喪。\n\n資歷我們渴望在職涯中成長，無論是角色或是能力。一些人對於 senior technical 職位感興趣，有些人則希望擔任領導或是管理職務。無論是哪種情況，資歷較深的人都會表現出關鍵特徵。在妳的整個旅程中，妳可能有 mentor 來指導妳成長。以下是我培養素質做好準備可以成為 senior 職位的方法。\n資歷以及戰略思維在不確定的情況下，不要不做決定或不採取行動。很多時候妳會發現，做任何決定比不做決定來得好。至少讓其她人知道知道妳傾向於什麼方向。有時候，作為領導者，我們沒有花足夠的時間去反思團隊期待我們做出什麼決定，但事實並非如此，因為我們不能 100% 確定我們掌握了所有的事實。我們可以而且應該嘗試盡可能完整的了解做出自信決策所需的細節，但這並不是總是可能的（例如，在時間緊迫的情況下）。這可能會導致團隊長時間的等待/不確定，在這種情況下，即使在訊息有限的情況下，也能幫助自己積極地更好的做出決定。\n領導者是擴展視野、進行戰略思考並為她人制定路線圖的人。理想情況下，妳的戰略性思考和計劃能力以及將妳的思想應用於更大範圍的能力應該隨著經驗而增長。作為一名獨立 contirbutor，妳可以專注於指定的任務或者是妳正在處理的功能。在妳攀登的過程中，妳的工作影響超出了具體的任務和 project。在權衡各種選擇時，妳要學會從利益和限制因素的角度來看待大局。軟技能的應用範圍也在增加。例如，如果妳早些為團隊做決定或，或與妳團隊中的工程師交談，那麼隨著妳的成長，妳的選擇和溝通會影響到多個團隊。\n\n以身作則指導妳的團隊如何釣魚。不要總是為她們解決問題，但要溫和的指引她們去發展自己解決問題的技能。工程界的領袖們授權。隨著妳的資歷變得更深，放棄妳的玩具、指導、授權並讓妳的團隊取的成功會有所幫助。這是妳如何擴大成效的方法。這可通過提出好問題來完成，而不是（僅僅）給出答案。\n當評估具有挑戰性的問題時，妳以身作則並在有人提出解決方案時提出相關問題。技術軌道內的前輩負責團隊內外的協調、談判以及建立共識。她們為提高團隊的整體產出做出貢獻，而不僅僅是她們自己。作為一名 senior engineer，妳可能偶爾會通過寫程式來獲得新技能或是瞭解實際情況，但這並不是妳的工作內容的一部份。相反的，妳是確保架構圖中沒有任何缺失或是程式碼中沒有任何漏洞的人。妳應該能夠用證據或理由來解釋妳的決定，說明它們將如何提供技術或是商業價值。\n一個 senior engineer 應該善於架構軟體系統以及人員系統或團隊。妳可以領導一個不同的工程師小組，委派任務給她們，指導她們關心程式碼的品質/效能/簡潔。妳可以在需要時給予 feedback，並在必要時為她們辯護。同時，妳應該能夠推銷自己，妳的工作以及妳解決挑戰性問題的能力，取得在組織中的知名度。總結來說，妳應該處理好與團隊內部人員和管理層的關係。\n\n提高妳的效率世界上最好的工程壯舉是由一個工程師團隊而不是一個人完成的。所以，妳如果嘗試去達成更多成就，或是表明妳已經準備好在公司中成為更「senior」，那麼就通過合作和指導來提高妳的效率。證明這不僅是為妳自己，而且為妳的團隊其她成員增加了價值。\n當我意識到要擴大自己的規模時，我必須將我的心態從「我」轉變成「我們」時，我覺得自己正走在成為 Google senior engineer 的道路上。透過與他人合作，分享我所學到的東西，並專注於提升我周圍人的技能和專業知識，我們開始完成了很多工作。\n當妳開始作為一位 individual contributor，妳可能沒有一個由妳領導的「團隊」，但妳可以找到志同道合的人進行合作（也許與妳的目標一致），共同完成比妳一個人更多的工作。隨著妳的資歷越深，妳會將這種思維演變為建立團隊和不斷提高妳的效率。\n\n冒牌者症候群接受犯錯，不知道但或是尋求指導是可以的，這有助於克服冒牌者症候群。我們所有人都曾在某一時刻對某一特定角色或工作感到不足。冒牌者症候群是真實的而且非常普遍。它甚至影響那些明顯成功的人。即使妳像別人尋求建議，妳也可能會覺得自己是個冒牌貨。妳可能永遠無法治癒這種症狀，但它會促使妳保持好奇心必學習新事物。\n\n指導指導她人透過提供即時的訊息成為護欄，這樣妳的指導者不至於在一個完全不正確的地方結束，而是通過自己做的事來取得掌握。在妳的職涯的不同時期，妳可能發現自己處於 metor 或是 mentee 的角色。 指導（Mentoring）不一定是一個正式的過程。妳可以尋找機會指導別人，或者讓自己接受指導，即使是非正式的指導。指導她人讓妳有機會去學習人際交際。以下是一些在指導時要記住的關鍵點。\n指導是為了引導人們發現答案，而不是給她們現成的解決方案。在解決她們的問題時，允許妳的 mentee 進行實驗。她們處於評估風險和效益的最佳位置。然而，請為她們提供找答案所需的工具。如果是技術問題，建議她們提出想法和方案來嘗試，但讓實際讓她們自己做。讓她們分享想法，並仔細聆聽，提出問題並且進行對話。\n如果有人無法自己想出解決方案，就向她們展示妳會如何解決這個問題以及為什麼以會選擇一個特定的模式來解決。教她們如何分析結果或是 debug 問題。分享妳分享妳在診斷問題、嘗試解決方案、實作解決方案和 debug 時的思考過程。分享妳的解決問題技巧而不是只給出答案。\n\n組織範圍內的指導確保指導是 senior enginner 角色的一部份，也有助於在有人轉調到其她部門、職位或是組織時保留關鍵領域的知識。假設妳真誠的指導某人，而且這也是妳工作內容的一部份。在這種情況下，妳必須在妳的 schedule 安排中，為指導空出時間。 這將使妳能夠正確地做到這一點，並使妳的 mentee 的生活發生變化。一些組織還可能根據職業發展階梯和每一階梯的要求，為 mentor/mentee 的討論制定了明確的程序。\n\nMentee 的角色Mentor 可以提供妳意見，但妳是唯一能夠主動並根據任何建議採取行動來管理妳的職涯和成長的人。假設妳是一個 junior engineer，希望能在一個組織中成長。在這樣的情況下，對妳只有一個建議。找到強大的 mentor 可以幫助妳導航至成長的階梯。\n在妳的職業生涯中，妳會遇到妳所仰望的 coaches、mentors 或是同事。她們可以提供妳如何發展技能的建議，但妳才是可以採取行動的人。在吸收建議時，請注意有空技術的籠統陳述。不同的情況需要不同的原則，對一個 project 有效的方法不一定適用於另一個。\n\n高效的團隊建立信任信任可以使團隊成員團結起來，為共同的目標而努力，而官僚主義會使她們分裂。當工程師們聚在一起 open-minded 以及 unbiased brainstorming 時，它為推動創新的新想法和不同觀點鋪平了道路。這成就了高效和高產出的團隊。然而，只有在團隊成員之間的溝通和關係健康的情況下，團隊成員之間的有效合作才有可能。這裡有一些關於建立、維持和成為有效率的團隊的一些要點。\n建立信任是團隊建設中最關鍵的組成部分。團隊成員之間的信任是快速完成工作和團隊有效的必要條件。團隊成員可以使用不同的軟體工程流程，像是審查和測試來檢視 project 的健康狀況。然而，如果沒有信任，這些過程就會變得乏味和官僚化。例如，如果妳信任一個工程師的程式碼，妳可能會在 code reivew 中減少挑剔。\n\n了解商業模式了解變化對業務的影響。當妳接收到一個新需求時，理解它們背後的動機。不要略過需求文件的「目的」和「商業目標」部分。提出問題來了解商業模式以及相關的需求。現有的 codebase 或是與主題專家（subject-matter-experts, SMEs）交談可以提供關於 domain 和 architecture 的見解。請參考文件或將 feature 和使用場景 map 到系統流程和 data flow。\n\n\n\n\n\n\n\n\n\n許多 software engineer 喜歡用技術挑戰來解決問題。了解商業面，並能夠提出具有成本效益的解決方案，會有更大的收穫。請記住，妳的使用者/客戶也是努力的工作，像妳一樣度過一天或一週。盡量不要讓她們的生活比現在更困難。1\n\n提高妳的影響力對商業軟體的洞察力和敏略度會增加妳工作的影響力。取得對業務和產品的 360 度視角有助於妳對團隊和 project 做出積極的貢獻。如果妳了解銷售和市場營銷的思維，妳就能更好的做出決定，並做高影響力的工作。隨著妳對團隊成功的影響增加，妳的工作滿意度和薪水也會提高。妳的前輩將會認知到妳作為一個 self-starter 的能力，可以在沒有監督的情況下獨立工作，透過做適合團隊、專案和業務的事情來提高整體效率。\n\n工作和生活的平衡如果妳是一個掌握技術能力、人為因素和領域知識的人，妳作為軟體工程師的技能將無一例外地受到歡迎。妳團隊和組織的人會向妳諮詢。除了妳的 engineering commitments，妳將會成為協作超載的受害者。臨時的要求會吞噬妳的時間並且阻止妳做妳熱衷的事情。\n\n時間管理為深度工作最佳化妳的行事曆。在妳的行事曆上留出時間來專注於深度工作。我已經這樣做了很多年，發現它對於撰寫設計和策略文件或僅僅解決一個困難的技術問題非常有效。深度工作是一個無干擾、高度集中的工作，可以在短時間內創造大量的價值。Cal Newport 的 Deep Work 很好地涵蓋了這個主題。\n注意力殘留是 Cal 談到的一個想法，即為什麼長時間的深度工作是如此有益。每次妳從一個任務切換到另一個任務時，妳的注意力殘留部分然停留在前一個任務的思考上。這使我們在工作中很難對真正重要的事情進行必要的關注。\n深度工作使妳在有限的時間內，通過專注單一任務，最大限度地提高生產力。沒有任何分心、沒有 twitter、沒有聊天或是電子郵件。妳把深度工作保留給認知較繁重的任務。我強烈建議妳嘗試一下。\n我還發現，有時候改變我的位置對於深度工作有幫助。我們有時候陷入將一個特定的地方（像是辦公桌、房間或是建築物）與一種特定任務聯繫起來的陷阱，增加一些多樣性可以幫助我們重新振作起來。\n\n避免分割妳的工作時間。因為分心所以把一小時的工作被分割成短短的幾分鐘時，妳會變得緊張。找出分心的原因（無論是妳還是別人）並解決它。否則妳的一天就不會有這麼高的效率。\n過度的工作並不是良好職業道德的一部份。妳永遠不可能比世界上所有人都更努力工作。許多公司把過度工作的員工作為「標準」，錯誤地認為這與擁有良好的工作道德是一樣的。\n成功來自於許多因素，而不僅僅是過度工作。\n不斷嘗試超越自己的標準是不現實的。我經常犯這樣的錯誤。如果妳想培養冷靜、避免瘋狂的工作環境，妳必須適應足夠的環境。作為 manager 或 lead，妳的團隊可能會在如何處理問題上接受妳的領導。對足夠的事情感到滿意可以建立一個好榜樣。\n時間是有限的。與其試圖尋求更多時間，不如消除不必要的任務。很多指導意見都談到重新安排工作的重要性。真正的問題是一開始就試圖完成太多事情。無情地消除不必要的和浪費工作時間的工作，與試圖管理有限的時間。\n妳不需要知道每一件發生的事情。我們當中許多人害怕錯過每一個新的故事或是更新。這也是為什麼人們總是每個小時檢查 Twitter、Reddit、Instagram 等等的原因之一。我當然也經歷過這樣的情況。在現實中，大多數的資訊沒有這麼重要。相反的，嘗試切換到新聞的摘要或對妳檢查的頻率設定限制。\nJason Frie 在「It doesn’t have to be crazy at work」這一主題中有進一步的思考。\n透過學習說「不」，知道何時停止，並計劃妳的時間，包括工作和休息之間，主動地將自己從疲憊中拯救出來。時間管理和保持良好的 work-life balance 對各個階段的工程師都是非常重要的。經常的超時工作會導致 burnout 和壓力。壓力會導致其她身體和心智健康的併發症。在妳結束工作之前解決一個問題可能很誘人，但隨著時間的推移，這可能會變成一種習慣。\n鼓勵妳自己和團隊有休息、假日以及假期。妳的健康和家庭是很重要的。如果妳作為一個 senior engineer 並且意識到這一點，為團隊中的其她人樹立一個優秀榜樣，這將促進整體的健康和幸福。另一方面，疲憊和倦怠會導致工作環境變得有毒害。\n隨著妳對問題的理解提高，更新估算。\n妳的工作幾乎總是會有一個客戶或利益相關者，她們會想知道一個 project 或 task 什麼時候可以交付，以及這個成本是否值得得。這很合理。有時候她們想 match 一個 deadline 或是在其她地方有依賴性，需要支援妳的工程工作，需要計畫。\n軟體的 deadline 是出了名的難以準確預測。基於預估的 deadline 只應該在 project 的特定階段時給出。當時間過去後，隨著我們對團隊解決能力有更多的了解，估算應該得到更新（”informed” estimate）。第一個估計（「sizing」）往往是最不可靠的，然而它是一個起點，可以時間的推移而得到完善。這個最初的估算往往是非常保守的 - 如果產品需求、UX 或是依賴性不明確，更大的保守估算往往對第一個「size」有幫助。當與 PM 進行估算的時候，我通常在這裡獲得最大的成功，因此我們都在同一條線上改進它們。\n軟體估算的麻煩在於：當第一個粗略的估算被固化為記錄的計畫而不是初稿。當團隊在關鍵的路徑上採用它，但將估算的調整視為一個小插曲（與知情估算的步驟 1/n 相比）時，這可能會是一個問題。一旦 project 獲得 greenlight，要更好的弄清細節 - 這可能意味著，根據解決需求的更深理解，三個月的估算可能會變成兩個月（或四個月）。\n妳希望估算能推動妳的 schedule 安排，而不是在可能的情況下讓 schedule 安排推動估算。在許多團隊中，雖然我們有時確實有不可動搖的 deadline（例如：一場會議），但如果估算超過了這些日期，（通常）沒有問題 - 改變訊息（例如：「預覽」）、framing（「即將到來」）或是推遲到未來，總是我們可以和 leadership 討論的選項。當然，我承認這些並不總是微不足道的。當 schedule 確實試圖被拉進來的時候，妳可以把工作分成必須做和可以做的（並把這些移到未來的 sprint），然後 review 必須做的是否符合妳的最後期限。\n如果 schedule 仍然太緊湊，妳還可以問一些問題，例如：「我們可以為這個 project 加入更多額外的工程師嗎？」以及「是否減少一個 large scope，仍然可以在時間內交付？」。\n取消 project 有時候是正確的（儘管是不舒服的）決定。\n我討厭這一點。但取消一個 project 有時候可能是對妳的團隊和阻止最健康的長期決定。如果它在有機會啟動獲得牽引力之前被取消，然後最終不得被廢止，因為它的人員配置不能夠維持，那就是更是如此了。如果大家想知道，是的我讀過 Killed By Google。盡量減少導致 project 被取消的情況。我最近取消了一個多年的 project，這很艱難。\n這種情況什麼時候可以發生？妳可以對投資一個新 project 做出決定，這些決定在某個時間點上是正確的。在那個時候，星星可能已經排列好了（市場適應性、組織買入、人員承諾），這樣做才完全有意義。 一年下來，事情會發生變化 - 市場、leadership、project 的重要性。定期的檢查妳在 project 開始時所做的假設是否在其生命週期內繼續保持真實性，這一點至關重要。\n妳越能保持對假設的信心，妳就越有機會使 project 能夠成功 launch 以及繼續得到支持。取消是很困難的，原因有很多種，尤其是有真實的人帶著真實的情感投入到建立她們希望推出的東西。作為一個 leader，引導夥伴從一個被取消的 project 回到其她的成功 launch 的 project 上是很複雜的，但對於人們回到一個心理安全、信任和快樂的地方很重要。在客戶方面，要注意使用者的信任以及妳的長期決定會如何影響這一點。\n關於技術債：一盎司的預防生過一磅的治療\nTitus Winter 將技術債定義為：「我們今天擁有的程式碼和系統與我們希望擁有的程式碼和系統之間的差異」，某些類型的債務比其她類型的影響更大。有些債務可能是由於沒有及早發現的錯誤（疏忽），有些是事後瞭解到的情況（事後諸葛），有些則是由於技術系統的格局變變化（context）。\n我發現優先處理技術債有時候是很困難的，因為妳不可能總是量化那些沒有表現出來的錯誤或沒有發生的故障，因為妳「償還了足夠的債務」。保持團隊對於這種工作的興趣，並在績效評估中給予獎勵也是非常重要的。然而，一旦問題隨著時間的推移開始堆積，「治療」的成本就會高得很多。與污染類似，在多年的時間裡，預防技術債是比一個後期緩解更便宜的策略。\n妳能做什麼來預防技術債的累積？技術負責人應該在 sprint 階段定期投入時間，除了建立新功能之外，還要清理和償還技術債。Reviewer 應該認識到對短期速度的推動，實際上可能會導致進一步的問題。管理者和主管應該注意批准與現有重疊的新 project，除非妳確定這種 trade-off 是值得的（例如，解決現有系統的技術債與建立新的東西想比是不值得的）。在這一切之上，對 project 的健康監測是很重要的。\n如果沒有良好的休息和工作與生活的平衡，妳或是妳的團隊會 burnout。\nBurnout 是一種由於工作的壓力沒有成功管理而導致的疲憊。我看過許多工程師在大流感（pandemic）期間由於工作壓力而 burnout，但它一直存在技術領域。這些日子，我在每次 1:1 的時候，詢問我的 reports：「妳的壓力水平如何？我能做些什麼來幫助妳？」。\n我對 burnout 的經驗是，它發生的很慢而且以冷漠結束。妳慢慢開始感到沒有精神、沒有動力，以及疲憊不堪，同時盡可能的嘗試應對工作的壓力。妳質疑自己是否有問題，但沒有意識到妳的身體正在超時工作來彌補妳的精力不足。妳不斷把妳自己逼得越來越緊，最終感覺已經沒有東西可以給予了。\n我大約在五年前遇到了 burnout，然而很高興的說：我扭轉了它。是什麼導致了 burnout？它是一個雪崩式的事情。多年來我一直把工作放在第一位，工作時間越來越長，沒有足夠的時間說「不」。我從來沒有享受過足夠的休息或假期。我當時每晚平均睡 5 小時。當我在家時，我的精神非常差，以至於我沒有像我應該做的那樣為我的家人「存在」。「修復」是做這些事情的反面：休息、獲得更多的睡眠，從我工作的時間擠出更多的價值、更好的價值，並有一個明確的「停止工作的時間」。\n作為管理者，為了避免我們的報告被 burning out，我認為重要的是嘗試鼓勵我們的團隊使用她們的休假時間，休息並檢查各位在壓力方面是否還好。\n在大型的組織中執行可能會感到很慢。有一些方法可以駕馭這一點。\n我曾與工程師進行許多談話，這些對話結論為「為什麼 shipping X moon-shot 在（大組織）如此困難？」。Alex Komoroske 有一個很好的比喻，她把大型組織比喻為黏菌（slime molds）。也就是說，由於協調方面的阻力，即使是簡單的事情，實行起來也會比妳預期慢的許多。組織有複雜的系統、結構和動態，當必須在一個 project 上協調的人數增加時，阻力就會增加。\n這裡有許多力量在起作用，包過低估她人任務的難度（例如，如果她們正在建立一個依賴關係）。妳不能忽視這些問題，因為它可能使功能障礙擴散。通過這種逆風工作的一個方法是盡可能讓事情 decouple，以便它們能夠能夠在一個確定的時間線上著陸，並最終向 shipping X 前進。\n與其一開始就處理所有的 X，妳可以避免只為 moot-shot（大風險的努力），而是定義 roof-shots（解鎖價值的安全步驟），使妳更接近目標。如果這個問題聽起來很熟悉，我強烈推薦妳閱讀 Alex’s 的投影片。\n專注問題與專案\n讓我們想像一下，妳的使用者有一個未解決的需求（例如：一個問題）。當妳是一位附屬於特定 project 的工程師時，問妳的特定 project 如何解決這個問題（局部最大值）是正常的。在一個類似 project 的大型組織中，很有可能看到多個工程師嘗試獨立地這樣思考（「我的 project 如何解決這個問題？」）。當妳擁有一個 project 組合時，這可能就不太清楚了。如果使用者可能同時使用妳的 project 怎麼辦？如果她們各自以稍微不同的方式解決問題而不知道對方的方法時，這不是很奇怪嗎？相反的，妳要問「什麼是解決這個問題的 end-to-end 解決方案？」並回頭來看哪一個 project 或對一系列 project 的修改能最全面的解決這個需求。這可能需要讓從事多個相關 project 的人進行更深入的合作。然而，這可以使妳的使用者在最後得到一個更好的、不那麼混亂的故事。\n\n結論\n\n\n\n\n\n\n\n\n“Surround yourself by excellence and work with people who are the best as what they do”（讓優秀的人圍繞著妳，與那些做得最好的人一起工作） - Brian Staufenbiel\n投資與妳可以學習的人的友誼和關係。對她們的指導、輔導、她們的成功和她們在失敗時持開放態度。永遠不要害怕尋求幫助或是 insight。在很多情況下，它只是一個問題而已。\n在每一個階段，請記住在一個特定的組織中，對技術、業務領域和人力資源的的掌握必須經過長期的培養。一個組織不可能從另一個組織 hire master，並期望她們從第一天起就有成效。如果妳是一名優秀的工程師，妳將為組織的發展作出貢獻。作為回報，新的途徑將提供給妳，使妳能夠獲得新的技能和自我成長。\nWith thanks to Leena Sohoni, Joshua Cruz, Kara Erickson, Jeff Posnick, Houssein Djirdeh and Sriram Krishnan for their kind feedback and contributions.\n","slug":"Software-Engineering-The-Soft-Parts","date":"2022-09-19T15:57:34.000Z","categories_index":"Research","tags_index":"経験","author_index":"Chico"},{"id":"5e62061c9f208a2f7cd0177aa343b6ca","title":"Centos + DVWA 架設","content":"\n  336934a14b4c6f0f6b9d9e85dafc3d4991ab9a42ea866035c765d3d543591c06abe5ba740b4b34a01dd4230b76aef7582faeb6f3bdc45333715fef3c390f68d539c2fdef2312b5e20ff5e79a7e953af6928ee807f248a860443b7c7393ad2ffef629f4e8b6c7a95e60faf65af0ce47e27166511a2b2c8fcf39d0050a0c6e32d3035dbb9f1204c45545a732bd20c1c18fddc2f7506842f3c696d258940d25b8c9a22991a2d4f7b8ac4ab21e58f478777ec29a1cb045ea817a219a763c21c7ae23d750a1ca88780044185e2047453c72e688ba57bb91e713ba0455945ec3bb8e23f675805a3ce2cd9380a25bd2f47636e68df73a1011f41eb247116a38732cb3460983c75e916adff312f5735506266d1094c113aa2fd654d43832145872f3f233a33c53cdd2d8af664c14844d24e8c10dd110e20da4987310592560c7848c97c5948f1b0ae6cd89451115957d637f55a6a22f20d1babca02d4da40b36905030f6f3d8bc8536dba5f8446ff1f51bfc265f9183a35ddb02adbb18668963229e95a9b8e33e10256f319afa93fca3d3cdc0c50066efb842c24e9f8a3c5b9dd87f96649afb86451408526a303c9a7c63e67df15a88b6ad6e2485b411a0270aac550d2fa9da5c9d042e29c0560a4a09f30d6698e048576b7c6819c793f0cb46c508a7e56b314bd6254225e4e962146824c04dfb1245ebff269c6ea426ca978acf453ba43fe2cc62184db85ff2c43142bf236b02ce61105ddca9cbe33c8d298d94b0793d709c4fe1d724ff22dfdfd788bc9d8c106e009ef07580d8eb035f62cacd0b829f9c7edd54dc3c7aeee8b8fa751480b421a49633daa2a19a30034dd871263a48732352878585125f9b127e92d99f96e93936f9ad52b1dd212293fc3fbaa1f1d18d40010e2f8e958f7c4499e6ead8efef3486df89d95b8d268b476d56d5ba5b6608c11215e8bf00ec36d3ff2c63e68bea2965820cc097b3fa3c056e21be45a4137262e5ad08fc61aeb8c69831d3373f2e440d64f93f05fbd8448fb0d64b39a04c9e920b326e27d450a92e74e756982651e652bbb3b7aca8f6df8df42431985a11196e4eec083d7d3a8b097bb8cb0300179406586d1f70c5d1396bf9f2f15507d81f201a10b57d4e7bc0e7b8fb0c7730b4442a467aa4f015a480d571de10ebf3af29cc42a44d32486dfa5ee90710523a89d6c458e30293745ecd4f493e7189656fe023943e680a8dc46d316a20b23fcebe2fce1794f5e0eb3a15ee73bd453932b76c286a4878bd26cd9012ab58248e928766a0870cdfbf7d07149b51eb39e67954ba91131d0c5f7cb2307c1c480b5e46f673bac2566c36a88ba4f2a833badca84789981eda9878cdb2b82781a4642ec4f4888f01defdb5cdf57ca7a6c01b6df11a19c52017c867278cb1e4b38664dcc6450e82166802ed134a6d3b952ca503c8bc041bc50f954151ba1154158baa2cb072e2a31e230cc83bd2fcca568d71d5d7b882cef40320e0e7651c16d73d2ad0b319ec66add615c7a66f105f9d12b70c6bbfb603badf0fc69422164bcb85f8ad6796645911841f637b433c352a9b7587835e350a03ea76ca1ec458afcefcd5915eacaf1aabf05fc1d2914337732a9e08dda9c1d0e4411820e2a60286fee49ecd0913bcd4b5d26d27fc614d9ed1d47d7c7548f1a2f6e2f3304ae7cab61ffde13bd2bdb121c3825466ef9283b7833457354338a2c99094ccff7f004e72d8858c9ade1c42ab53000dc2dabefb4a0e149da6969e116fcf758ccb9f474c884f6f669bc8083e1edf8496239f841cfc7df24bb9367380a50b4f8d46a22f82750a70118fb9f425a023dac08e29fc70977bd021dd06e58c0775a6aec54d643ce9fbb60b12f0129c5c8a6b09db89508ffb977b7d703f44be38b695b50878b01d7a45f61d9d1d619895d13d7d90d7e9994ed0a0b5b54dae496dbbd2911487d9fc902a70bc95a8511bd49a1c6d863897b3d5cb943643e5a880a77b49cddb10883274206d9932da5706846abb427ff87abe3da0e2409356de590a1923bd8fbde154fb71093fbfcd046a0a40b9dc4367bb3a8fd6360ac2d55af0701c38a5bd40e659457dbc138e9f3e31b4991194f7392980e2a4f31fe6fc168e4914eada92f09bafe4b4faac0e1a0a30c8811e393e36989af6ad100b8e877d5b64ec32ddc405db6477ab19846b47db1e937f444f5cbe5dc46ac8f7d81114fd110ca3898554a4fe18b2c797aa03a7d2f2b3d594e0e81fc5d6c20e57744350ec9cad03be17771f13d65c9997480f26bdb06f9c40ad467c71a873a4e110ebc6d5beb622388ec7bf683dfa8c95355bc4195c96cc47fc80ce7013a947fc57af1da06bea6bdc0256c11f9fe2f3a8a0c9e7759fd43951becb07c50e0c48f1aa8334a756aec7f54e00eae3c90b77267b173bb1afbba87ab8d9b19edaac03b122239272525ee021460102a006d73738fdb5da1c3af1ff78cf47579b5db28fdddc6a6cedd98178747c55b3df15a768524ad245adb769ef30b3da9dc794d88bda4af56266d4a8aa7a4be06daa83d03ebdd1d1e9ef570c7a063b3254c3b1e082692c89ef328d1662ed89219c39f578e3db35897cb7228c4cc9957f314b979a2e06956373e60d5fcb0bd5d473a95c4f6eab6495627b2efe2a6f791cf6e622eb40029f28692329b8c6454071ac79e83c865b51504496a2d210874c8f4640d2ff57411011e64048cb547932d9dfa44728abf9044a48d6b60b1e4c6db49bf48de93836e25acb8c94422aceb02e0db887734a41bf7697f900606d5920aa9b801ee329df2fb33a8225f52d8e24ea340c7ec42edd9d98cda6cc392b1993e929d2ed36f679cb25febfa17a4ba9b3f29adb94a5cc56c11319ed4cb62d96464db3d113aec69f9bd0f0db60fdf75487f7e7d0f47edaf3ccd9eb5181a095f79b26f657b6a452cf01e03087b77a8a82554921b8252150d805f0cc87623a04d446ab7f78273efeab814f689a8319d0ebfb7e0b644fb6eca6d23765285b1e6562ddc646ef7b12c50e69789432805a9fade61f5c4f09928318c42edc8a6c1e4f0df2a52421c4c01bf28a8a931e06e64f4df8c7ade7293da599c0034f4714f67a79fd4e7056edcff8df31550cec22b74fa8854a84902794abaea91d5aee3585d01780ed38ec8bb0c7a2fecbbf0127b01f34342e2791f9b74b624a8d781197897eb5c083aa6535194b7cc239f735368d518f38b028fc6713cd74b509be6efa1172518d53449d9f660d5588e780d3ad42d75c273037e711cce794f30431784f63c1d3bec3e0411c1a11351b68144295a15c59684eaae7c443df96582a7b95dbcb80a8ea452a6bc1e87d92ba37faf4778c54d730a595114105a55d155288cf17518bfbe822698b6f14992a8fecc054be3ba4a789d3bdf01001e4cbe5bf24fa7afd23b8235a68ae745fe958a440604edb2132eb5110926d2a46c7d52bbdc26cae60e4a02f1cf02e76cd580be5002b32586d1e577761609ce3f147f8d27ac579c3692238a1227521748463021ed736f05d10da1027ac120e344e364eb6e6a4d1b4d7b55f8459e8403adf2fcbd3b51e72c889a3591dbea2732a573cffce89655401bc5b7fbcc05badd6ff1139b7eea668e80862135d21102ad09ea99681f086212471491f679f59833b1347aa7dd597f6c0c14c7c7e52171d56027c639a1cf368f57a08a5f67729cfdf6fb649db58cb0839396a78db86f7a06e8e25edcd4d36d1680816610a2e2954e304cc8730514871d7796118ea9f054599e7dd6dc8f8d5938bb7a158da6c2f80f70c427c4a89b619a378be535e380466063c259d5f86a5f38c5855c3ef43c633cb86a58d9ace40d387dac840e0d2b7b5f0cab701dfe5b2b53bc0f60ea8f1099624de2a60d2265f44a7a121e77c45300abadeaf2e2b84e214100c15b61a01fbc5da32cb80748da49901a15ecb60c78224bb39cd4e2ab9da21d3bc6f3b3465b34ab800ec7cd5e3632c2fe7a6e1e800071cd6c82ac7753ee8844dfd756edc5bae02f15ef90a3ac1252b036f909c9bc8b9ad34def9ee2ca3f9898e5362b9aae639139bc2998a62e48f5f1e207efb417020498c862617ec8c0d6db8ff96fc72c361171754c9533f7bbbe885fef511662958147fe0adc97e48048bfe9379451a2d6ee5e3c6b3ec5af185b10297ccb78d5f27995baacde7d02d104a2685c219b8753ba48d64d5ed26a236308fc24cadfde65d36dce701cfb556de70a34a626f347ec5b60a1159548440920caff167676887bb2a01a06e7677a1aed34b2801503bace029796dee6e2c815ee6244975ef478bbca8445925c4adca33d97794403b7f658ee1522e25d807714560498323a74a925f3fbc4f5fefdf1e364df865cd6dc54fe0cacc27ef611bfaaa8a329cc7762612a6b32d21aedff5e0b870b48720bf5ee0968de778d4409303c78f2a581896adcea883cd9ed1f9ceb0a54fae292ca62598670461447fa1c03a61d3eb42ace7c7ccd7fe281705d62af36fa702c682aaaa684464101920348c8649318b2c04441dfb9f9257cc614cc45eb64e574da31f6bbbab96e204b864b2ed231dfa69cb04514c6a6a567ac9bb2fe43dbf6c38128c65a07b0e296bfcb4bb1b08ae8686a4e596f5f580fd1afd6b1aa4afd0bf4c8df20ca33b03e184e211f81d55e07ad47e096783722f2dcb2559ec6fc8e31ee16547e57559371bbafbbade3f2dcaab1d3ce38368bd2ad900bd0b8e0a9ad5764b98ec5689d1c5fa3629ac1a6eff8cbaac9a75eb150367ee5c8c42e38349b8e710deb0149566b45118217ccc4a53913bacc00d9462acea73d69d2c6513c2d17fb3ed090093756a597b72a65084d21ded3b041770dce4fb8a6aba2bd63975ed10de115a6f5ce15f8f0309031bf22852576d7fc85c0c4b185a84eefef2440d6b0b29f332ba393f5e421bc8f8eab936fb61084c8bbaac29a6709cd7915f08510a8d049987c419c0c140a777480fb39b8dc313680b965192bfa6bf9f00a418cb29fe812a2c5c6f4c1073a479950710af01621558f1382480f4fb476bae7718f3f34c784edffaa74772e23d9660d28fb0858e4411c8cb1e38de3b221a9b5261c4d6bf9136b28cd561f9c558bc2868b61de00dea5b8d35eaaab81c2284aaa1d48d7348109770bc58ed861b03b32f917e6365b4b73a7fbb41394ed11d2bca484c504fce7e9d7a3410ab4bf48d1bfdf15ea07012fb55c4b8ab691d6556fb45c9516c14c8189b2e6db4fc8e86947e76a77723177a56ad57b2cbfe3f83be9c738d8569c1e4a3c1249d5434c2d1331a10385712c0a790b8f9a81ac43ae0b6d0c079739f615c9f177ec1db5a4249c4e20fdd29536b66d2a1d17fc7c98c3bab97d96f3f3503ce9749ba04e5c9b74a908f92f4e4f752132d1fec964aeb6815d3251b0da45db42deaf7caf610749a79916702e9ec7d51ac572837413a0b4aee2ca67fc461f231f1d4d199b83e366318bfc2c86ac2d4f893d0efb53fea5057cdd2b7993b717e010750cbb92583ae0e2b21fc4aea7df6ee70b49a99c4308abef33be4cb3568b7c81ca20d919b3127fb0f6ab4f588ecd2e12209cef5036eba094855f17ec0583848eebea59d02658430cb6275bd7802a953b5ef9476ffa7c866c721e46cc9fb11782a5df5866d65e73113b168b1d7b31ab67bffe7a5eefcd510c069801aad5a5ff5c5\n  \n    \n      \n      \n        Hey, password is required here.\n      \n      \n        \n        \n      \n    \n  \n\n","slug":"DVWA-架設","date":"2022-08-11T01:34:33.000Z","categories_index":"","tags_index":"","author_index":"Chico"},{"id":"0b8ad14607102942f850bab881ab4311","title":"VScode::Synthwave'84 更新","content":"\n\n\n\n\n\n\n\n\n\n\n此篇為各筆記之整理，非原創內容，資料來源可見下方連結與文後參考資料\n步驟\n若是先前有安裝過 Custom CSS and JS 模組，並啟用它現在需選擇關閉Ctrl + Shift + P or Shift + ⌘ + P 輸入 Disable Custom CSS and JS\nCtrl + Shift + P or Shift + ⌘ + P 輸入 Enable Neon Dreams並重新啟動\n\n\n\n\n\n\n\n\n如果已經有開啟的檔案，再開一個新的就算重開\n\n如果遇到圖片上問題，確定關閉 VScode ，選擇以系統管理員身分執行\n如果還是無法開啟，修改C:\\Users\\&quot;YourUserName&quot;\\.vscode\\extensions\\robbowen.synthwave-vscode-0.1.11\\src\\extension.js大約 33-34, 39-40, 112-113 行將 electron-browser 改為 electron-sandbox1234567891011121314151617181920212223    const htmlFile =        base +        (isWin-           ? &quot;\\\\electron-broswer\\\\workbench\\\\workbench.html&quot;+           ? &quot;\\\\electron-sandbox\\\\workbench\\\\workbench.html&quot;-           : &quot;/electron-broswer/workbench/workbench.html&quot;);+           : &quot;/electron-sandbox/workbench/workbench.html&quot;);    const templateFile =        base +        (isWin-               ? &quot;\\\\electron-broswer\\\\workbench\\\\neondreams.js&quot;+               ? &quot;\\\\electron-sandbox\\\\workbench\\\\neondreams.js&quot;-               : &quot;/electron-broswer/workbench/neondreams.js&quot;);+               : &quot;/electron-sandbox/workbench/neondreams.js&quot;);    var htmlFile =        base +        (isWin-       ? &quot;\\\\electron-broswer\\\\workbench\\\\workbench.html&quot;+       ? &quot;\\\\electron-sandbox\\\\workbench\\\\workbench.html&quot;-       : &quot;/electron-broswer/workbench/workbench.html&quot;);+       : &quot;/electron-sandbox/workbench/workbench.html&quot;);\n然後再重開\n\n參考來源\nSynthwave ‘84 has changed.\nWhy can’t SynthWave 84 enable Neon Dreams on windows?\n\n","slug":"VScode-Synthwave-84-更新","date":"2022-08-10T23:57:49.000Z","categories_index":"","tags_index":"","author_index":"Chico"},{"id":"f033e15d4344e177894d0da932e5ec1d","title":"Virtualbox 6 與 Hyper-V 共存","content":"\n\n\n\n\n\n\n\n\n\n\n此篇為各筆記之整理，非原創內容，資料來源可見下方連結與文後參考資料\nVirualbox（以下均稱 Vbox）以小巧開源免費等優勢與 VM 和 Hyper-v 同台競技。而 Hyper-v 靠著”巨硬”這個爸爸在 Windows 平台上也有非常優秀的表現，特別是最近 Windows10 新更新的 “Windows 沙盒” 與 “WSL2” 這兩個非常棒的工具就是使用 Hyper-v 虛擬技術實現的。\n但是這又會遇到一個”致命”問題，那就是 Hyper-v 不能與 vbox 和 vm 共存，原因是 Hyper-v 的虛擬方式不一樣，開啟 Hyper-v 後會將用戶的桌面系統給虛擬化，用戶的桌面系統就會成為 Hyper-v 的虛擬系統，而 Hyper-v 的虛擬系統是不允許再開虛擬機的，因此開啟 Hyper-v 後 VM 和 Vbox 就不能運行。\n\n而 Vbox 在第六個版本（Vbox6.0）中新增了利用 Hyper-v 的 api 進行虛擬化系統\n\n\n\n\n\n\n\nWarning\n這個功能還是實驗性的功能，可能會出現意想不到的問題，出現問題請向官方反饋以助於完善。\n\n 由於這個功能還是實驗性的功能，所以沒有現成的 GUI 按鈕或界面開啟這個功能，需要使用命令行開啟。找到 vbox 的安裝目錄，確定目錄下有 VBoxManage.exe在該目錄打開命令行工具命令窗口輸入\n1234567891011121314C:\\Program Files\\Oracle\\VirtualBox&gt;#指定vbox下的虚拟系统开启这个功能VBoxManage setextradata &quot;&lt;虚拟机名字&gt;&quot; &quot;VBoxInternal/NEM/UseRing0Runloop&quot; 0#或指定vbox所有虚拟系统开启VBoxManage setextradata global &quot;VBoxInternal/NEM/UseRing0Runloop&quot; 0PowerShell需要加`./`和`.exe`#指定vbox下的虚拟系统开启这个功能./VBoxManage.exe setextradata &quot;&lt;虚拟机名字&gt;&quot; &quot;VBoxInternal/NEM/UseRing0Runloop&quot; 0#或指定vbox所有虚拟系统开启./VBoxManage.exe setextradata global &quot;VBoxInternal/NEM/UseRing0Runloop&quot; P\n參考資料\n【雜項】Virtualbox 6 與 Hyper-V 共存\n\n","slug":"Virtualbox-6-與-Hyper-V-共存","date":"2022-08-10T23:27:07.000Z","categories_index":"","tags_index":"","author_index":"Chico"},{"id":"09cda6f669100b0f7ef5ff5b34cc625c","title":"CTF::CTF環境搭建::CTFd","content":"\n\n\n\n\n\n\n\n\n\n\n此篇為各筆記之整理，非原創內容，資料來源可見下方連結與文後參考資料\n步驟更新\nsudo apt-get update\n\n\n\nsudo apt-get upgrade\n\n\n\n安裝 git\nsudo apt install -y git\n\n\n查看 python 版本\npython3\n  Python 3.8.10 (default, Jun 22 2022, 20:18:18)\n  [GCC 9.4.0] on linux\n  Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n  >>> exit()\n\n\n安裝 pip3\nsudo apt install -y python3-pip\n\n\n安裝 flask\npip3 install flask\n\n\n下載 CTFd\ngit clone https://github.com/isislab/CTFd\n\n\n安裝 CTFd 及相依套件\ncd CTFd\n\n\n\npip3 install -r requirements.txt\n\n\n執行法一::本地訪問\n\npython3 serve.python\n\n瀏覽器輸入127.0.0.1:4000\n\n法二::IP 訪問\npip3 install gunicorn\ngunicorn --bind 0.0.0.0:8000 -w 20 \"CTFd:create_app()\"\n\n\n遇到問題1Command &#x27;gunicorn&#x27; not found\n解決\npip3 show gunicorn\n  Name: gunicorn\n  Version: 20.1.0\n  Summary: WSGI HTTP Server for UNIX information.\n  Home-page: https://gunicorn.org\n  Author: Benoit Chesneau\n  Author-email: benoitc@e-engura.com\n  License: MIT\n  Location: /home/hunter/.local/lib/python3.8/site-packages\n  Requires: setuptools\n  Required-by:\n\n\n\nls /home/hunter/.local/\n  bin include lib\n\n\n\nexport PATH=$PATH:$HOME/.local/bin\n\n\n\ngunicorn --bind 0.0.0.0:8000 -w 20 \"CTFd:create_app()\"\n\n\n瀏覽器輸入[yourIP]:4000IP 查詢\nifconfig  eth0: flags=4163  mtu 1500        inet 172.31.123.234  netmask 255.255.240.0  broadcast 172.31.127.255        inet6 fe80::215:5dff:fe77:706d  prefixlen 64  scopeid 0x20        ether 00:15:5d:77:70:6d  txqueuelen 1000  (Ethernet)        RX packets 64844  bytes 284195303 (284.1 MB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 58124  bytes 4043443 (4.0 MB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n  lo: flags=73  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10        loop  txqueuelen 1000  (Local Loopback)        RX packets 503  bytes 3713955 (3.7 MB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 503  bytes 3713955 (3.7 MB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0&lt;/code&gt;&lt;/pre&gt;\n參考資料\n【CTFd】教你如何用Ubuntu快速搭建一個屬於自己的CTF靶場\nwhy gunicorn command not found with gunicorn installed?\n\n","slug":"CTF-CTF環境搭建-CTFd","date":"2022-08-09T22:08:04.000Z","categories_index":"CTF","tags_index":"","author_index":"Chico"},{"id":"15abed8e3de2cb24b4873715dd5d75ef","title":"百度網盤加速技巧","content":"\n\n\n\n\n\n\n\n\n此篇為各筆記之整理，非原創內容，資料來源可見下方連結與文後參考資料\n簡易下載助手由網友”軟件小妹“製作的網盤助手腳本，可以通過拓展 Tampermonkey 或者 VolientMonkey 來啟用。\n原理是通過顯示百度網盤下載直鏈，然後使用 IDM 這類多線程下載軟件來加速下載。\n1、安裝下載腳本你可以自行安裝腳本，又或者直接使用下面的定製版瀏覽器（二選一）。\nFirefox 定制瀏覽器：https://www.lanzoui.com/b0ufrtlc\nChrome 定制瀏覽器：https://www.lanzoui.com/b0ufru1i\n2、安裝下載軟件安裝下載軟件，Windows 推薦 IDM，Mac 推薦 NDM。\nWindows 和 Mac 的使用方法完全一樣，只是使用 NDM 來代替 IDM 下載。\nPS：你可以在公眾號回復關鍵字“ 1024 ”獲取。\n3、修改軟件 UAWindows：在 IDM 的設置裡，將 UA 設置為 netdisk;3.0.0.112\n\nMac：在 NDM 的設置裡，將 UA 設置為 netdisk;3.0.0.112\n\n4、文件下載方法首先選擇要下載的文件，點擊”簡易下載助手“，然後點擊獲取“直鏈下載鏈接”，最後粘貼到 IDM 或 NDM 中下載。\nWindows 下載演示：\n\nMac 下載演示：\n\n5、注意事項注意！不支持「文件夾」下載，否則會報錯。\n需要下載多個文件，大文件，還有文件夾的，建議充值官方 VIP。\n資料來源\n3個方法解決百度網盤限速（2022-08-04）\n\n","slug":"百度網盤加速技巧","date":"2022-08-04T18:03:46.000Z","categories_index":"","tags_index":"","author_index":"Chico"},{"id":"51186fd5b0b828941bd4bda2bbd8b00b","title":"研究生新手剛開始應該怎麼看英文文獻?","content":"\n\n\n\n\n\n\n\n\n此篇為各筆記之整理，非原創內容，資料來源可見下方連結與文後參考資料\n前言千萬！千萬！不要從頭到尾按順序看！\n強烈推薦美國公立常青藤明尼蘇達大學Peter W. Carr教授傳授的閱讀順序\n明尼蘇達大學是世界著名公立研究型大學，在2019年USNews世界大學排名中位列全球第41位，截止2017年，共有30位校友及教職員工獲得諾貝爾獎。\nPeter W. Carr 教授在明尼蘇達大學化學系任職，從事科學研究已有四十年左右，明尼蘇達大學官網上的個人主頁截圖：\n\nPeter W. Carr 教授獲得過的部分榮譽和獎項：  \n\n文字總結第一階段：判斷這篇論文值不值得讀按【讀標題和關鍵詞→讀摘要→讀結論】的順序掌握論文的大概內容\n第二階段：讀論文\n讀圖表和數據→讀引言\n\n深挖細節：讀結果和討論→讀實驗部分\n\n\n第三階段：做筆記好筆記的標準：下次看筆記內容即可，無須重讀這篇論文。\n具體步驟第一階段：Surveying the Article （判斷論文是否值得讀）第1步：讀標題和關鍵詞推測這篇論文的大致主題和內容，以此判斷自己是否感興趣或者是否需要，如果答案是“否”，那就捨棄這篇論文。\n第2步：讀摘要摘要會說明論文的基本內容、方法特色、主要貢獻，是整篇論文內容的濃縮，非常重要。多數論文看摘要，少數論文看全文。\n第3步：看結論跳過前言、實驗方法等部分，直接看作者得出的結論，如果結論和你不是很相關，同樣地捨棄這篇論文。  \n\n論文篩選是很重要的一步。假設篩選前你有15篇論文要讀，經過篩選，你就只需精讀其中最密切相關的5篇，效率會大大提高。\n總之在第一階段，做好隨時捨棄這篇論文的準備。  \n篩選過後，就可以開始讀論文了。\n第二階段：Reading the Article（讀論文）\n第1步：讀圖表和數據數據是最不會說謊的，這是論文中最原汁原味的東西。在看實驗細節之前，先花點時間看下圖表和數據。\n第2步：讀引言引言的功能是介紹研究的背景，以及在這個背景下這篇論文想解決的問題和它的重要性。\n如果你對研究的課題還不太熟悉，那就先蒐集幾十篇和自己課題相關的論文，先不讀正文的實驗部分，只讀摘要和引言，快速了解這個領域以前研究的概況。  \n\n第3步：讀結果和討論結果和討論是論文的核心，值得花費大部分時間來閱讀。\n第4步：讀實驗部分這是論文中最晦澀難讀的部分，所以要放在最後。當你看完其他內容，認為這篇論文有足夠的價值後，再去讀這部分。這部分需要仔細閱讀，了解作者究竟做了哪些工作，怎麼做的，閱讀速度肯定要慢下來，花更多時間。\n第三階段：Take Notes （做筆記）\nCarr教授引用了中國的諺語“好記性不如爛筆頭”，強調在讀完論文後還需要認真做筆記。\n一份好的筆記，可以幫你把一篇論文的重要內容全部“偷走”。這樣下次僅需要看自己的閱讀總結即可，不需要再對論文進行重新閱讀。\n研究生階段和大學本科的區別本科課本基本都是非常有系統的知識體系，按部就班跟著學就行。\n但研究生階段的論文不同，論文是局部的、割裂的，只專注於領域中的更小領域，必須要靠自己從幾十篇論文中篩选和自己密切相關的片段，然後閱讀與吸收，自己組織成一個有系統的知識。\n另外，本科時我們基本都在被動地接收知識，課本即真理，它怎麼寫，我們怎麼學。\n研究生階段必須學會「批判的能力」，這個批判並非個人好惡或情緒化的批判，而是真的找得到充分理由去支持的批判，這篇論文的實驗方法可靠嗎？數據真實嗎？分析方法有效嗎？邏輯嚴謹嗎？等等。\n資料來源\n研究生新手刚开始应该怎么看英文文献？\n\n","slug":"研究生新手剛開始應該怎麼看英文文獻","date":"2022-08-04T14:40:57.000Z","categories_index":"Research","tags_index":"経験","author_index":"Chico"},{"id":"e595883d89cd424ec7758b2328f1e1d0","title":"在論文中如何交代你的「研究方法」?","content":"\n\n\n\n\n\n\n\n\n此篇為各筆記之整理，非原創內容，資料來源可見下方連結與文後參考資料\n蔡錦昌 20090916\n前言在論文中，「研究方法」一節必須回答以下兩個問題：\n\n資料是如何搜集到或者衍生出來的\n資料是如何分析的\n\n換句話說，你要告訴讀者你是怎樣得到你的研究結果的。\n但是為甚麼你須要解釋你怎樣得到你的研究結果呢？\n不習慣現代西洋人學術思考方式的華人研究者，對此也許會感到困惑不解。\n他們在撰寫研究計劃或者論文本文時經常不曉得要寫些甚麼，尤其不曉得為甚麼要花那麼大的力氣去交代研究過程，好像過程比結果更重要 ── 結果不對而過程對可以是好論文，反而結果對而過程不對就不是好論文，沒有瞎貓抓到死老鼠這種好事。\n以下姑且依據西洋人對學術論文的可能想法，列出六點理由略加說明。這六點理由同時亦間接指示了我們應該往甚麼方向去交代我們的研究方法：\n\n因為研究方法會影響到研究結果。譬如說，如果你在探討台北市捷運乘客對台北市捷運效能的看法，而你所使用的是可作多項選擇的問卷而不是對個別乘客進行訪談，那麼你所得到的結果就會有所不同。讀者若知道你用甚麼方法得到資料，即有助於他評估你的研究結果是否有效和可信。\n同一個研究問題可以有多種探究方法，你必須交代為何你決定選用某種方法來研究，而捨棄別的相關方法。\n讀者也想知道你得到資料的方式是否合於探究主題之常理。譬如說，如果你使用問卷調查法來探究台北市捷運乘客對於捷運效能的看法，而你的問卷中卻只提供「1.非常好2.很好3.好」等三種正向選擇的回答而完全不提供負向選擇的回答，即不合於此種探究主題之常理。\n讀者也想判斷你所使用的研究方法是否協合於研究目標。譬如在上述所例舉的探究中，你只個案研究一位乘客，這顯然就不協合於研究目標。\n你也必須談一下你如何預防本來預期會發生的問題，而假如真有問題發生時你又如何把問題的衝擊力道減到最低。\n如果你交代得夠清楚的話，有時候別的研究者會直接採用或者變相借用你的研究方法論(研究方法交代方式)，特別是你的研究方法論頗有新意，又或者借用者慧眼獨具之時。\n\n研究方法擺放位置至於在全篇論文中又該在甚麼地方和以甚麼方式交代你的研究方法呢？\n當然最重要的是「研究方法」這一章節了。在這一章節中你必須集中而扼要地說明你的研究方法。\n不過，並不是在這一章節中交代過就算了事了。\n在論文的其他章節中，也須適時酌量附帶說明一下。\n以下依論文章節安排略為提點一下：\n\n\n\n\n\n\n\n\n\n\n緒論\n研究問題介紹、研究目標介紹、研究程序介紹、主要研究結果與結論之選擇性介紹\n\n\n文獻回顧\n回顧與你的研究問題有關的已有文獻(針對它們如何界定、說明和正當化此一研究問題而談)、回顧已有的相關研究方法論文獻(同樣針對它們如何界定、說明和正當化而談)、回顧已有的相關研究結果文獻(特別針對可信度等來談)\n\n\n研究方法\n對獲取資料的方式和分析資料的方式詳加解釋、對方法論問題及其解決辦法和效果加以說明\n\n\n研究結果及討論\n研究結果之呈現、關於研究結果之詮釋與延伸討論(譬如跟已有的研究結果作比較等)\n\n\n結論\n說明研究問題是否有所「解答」、在何種程度上本研究達成了目標、我們從此研究結果中學到甚麼、從此研究結果中所學到的知識有甚麼用、此研究有何缺點等等\n\n\n\n\n常犯錯誤一般初學的研究者在交代研究方法時常犯有以下幾種錯誤：\n\n無關的細節講太多。\n不必要的初學者方法知識和程序細節仍然交代得清清楚楚，徒增篇幅。\n忽略了討論搜集資料時所遇到的問題，以及沒有交代如何克服困難和權衡輕重時的考量點。\n\n論文研究類型以下介紹一些比較常見的研究類型：\n\n\n\n\n\n\n\n\n\n\n\n個案研究\ncase study\n對於一個或多個個人、團體、社群、企業或機構之背景、現況、環境和發展歷程予以觀察、記錄、分析，就其內部和外部的諸種影響而言得出某些階段性的變化模式來\n\n\n比較研究\ncomparative study\n比較兩個或多個情況之間的異同\n\n\n相關與預測的研究\ncorrelation-prediction study\n求得一些因素之間在統計上有顯著意義的相關係數，並且加以詮釋，以作為預測未來類同情況之參考\n\n\n評估研究\nevaluation study\n判斷某種計劃或安排是否遵循預定的程序並且達成其明說的目標\n\n\n設計與展示的研究\ndesign-demonstration study\n建構、測試和評估新的體系或新的程式是否可行\n\n\n實驗研究\nexperimental study\n對控制其中一項或多項變異因素所求得的結果加以分析\n\n\n問卷調查研究\nsurvey-questionnaire study\n以問卷方式對某個特定團體的行為、信念和意見予以確定、報導並詮釋\n\n\n狀態特性研究\nstatus study\n對於一個或多個現象之代表性案例或者取樣案例加以觀察檢驗，以確定其特殊性格\n\n\n理論建構研究\ntheory construction study\n尋找或描述一些可解釋事物之所以如此運作的原理\n\n\n趨勢分析研究\ntrend analysis study\n分析目前事件之動力結構以便預測或預斷事件之未來走向\n\n\n概念分析研究\nconcept analysis study\n對於某些學術上使用的關鍵性概念作語意方面或邏輯方面的分析\n\n\n\n\n","slug":"在論文中如何交代你的「研究方法」","date":"2022-04-07T17:40:12.000Z","categories_index":"Research","tags_index":"経験","author_index":"Chico"},{"id":"b36af7c752e0f84c8846506465ce6a50","title":"Blog::滑鼠圓球跟隨","content":"\n\n\n靈感來源\n過程下列這個 code 是一開始最先使用的來源123456789101112131415161718192021222324252627&lt;style&gt;  .box &#123;    width: 30px;    height: 30px;    border-radius: 50%;    background-color: darkturquoise;    display: none;    position: fixed;    left: 0;    top;  &#125;&lt;style&gt;&lt;body&gt;  &lt;div class=&#x27;box&#x27;&gt;&lt;/div&gt;  &lt;script&gt;    var div = document.querySelector(&#x27;div&#x27;);    document.onmousemove = function (e) &#123;      div.style.display = &#x27;block&#x27;;      var radious = div.offsetWidth &gt;&gt; 1;      e = e || windows.event;      var x = e.clientX;      div.style.left = x - radious + &#x27;px&#x27;;      var y = e.clientY;      div.style.top = y - radious + &#x27;px&#x27;;    &#125;  &lt;/script&gt;&lt;/body&gt;\n要在移動時有延遲性，是根據這篇 blog 啟發的延遲性-&gt; transition 的部分[CSS筆記] transition、transform、animation 動畫屬性&gt;\n遇到的問題問題一後來發先照第一個網址的code改，無法達到我想要的成果(九成是我不會改)就看到這個網站 W3school 的 jQuery 事件 - mouseover() 方法之後的程式碼就照它改123456$(&quot;p&quot;).mouseover(function()&#123;  $(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;);&#125;);$(&quot;p&quot;).mouseout(function()&#123;  $(&quot;p&quot;).css(&quot;background-color&quot;,&quot;#E9E9E4&quot;);&#125;);\n問題二在測試的時候，發現小球在滾動頁面的時候，不會跟著移動接下來就從 這裡 發現這個 網站\n底下的13、var Y = ev.clientY + scrollTop; // 加上了滾動距離\n可以解決這個問題\n完整程式碼123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;請把滑鼠移動到這個段落上。&lt;/a&gt;&lt;div class=&#x27;ball&#x27;&gt;&lt;/div&gt;  &lt;style&gt;/* mouse ball */.ball &#123;    transition: all 0.35s ease-out;    z-index: -1;    width: 30px;    height: 30px;    border-radius: 50%;    background-color: #88c0d0;    display: none;    position: absolute;            left: 0;    top: 0;    &#125;&lt;/style&gt;&lt;script&gt; // make ballvar ball = document.querySelector(&#x27;.ball&#x27;);document.onmousemove = function (e) &#123;    ball.style.display = &#x27;block&#x27;;    var radius = ball.offsetWidth &gt;&gt; 1;    e = e || window.event;    var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; // 滾動距離    var x = e.clientX;    ball.style.left = x - radius + &#x27;px&#x27;;    var y = e.clientY + scrollTop;    ball.style.top = y - radius + &#x27;px&#x27;;&#125;    // 移動到 **連結** 段落時，圓球跟著放大縮小$(&quot;a&quot;).mouseover(function() &#123;    $(&quot;.ball&quot;).height(&#x27;75px&#x27;);    $(&quot;.ball&quot;).width(&#x27;75px&#x27;);&#125;);$(&quot;a&quot;).mouseout(function() &#123;    $(&quot;.ball&quot;).height(&#x27;30px&#x27;);    $(&quot;.ball&quot;).width(&#x27;30px&#x27;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n資料來源","slug":"Blog-滑鼠圓球跟隨","date":"2022-03-14T10:56:17.000Z","categories_index":"Blog","tags_index":"","author_index":"Chico"},{"id":"622b3593042700329fa56bf6ad7dfcba","title":"hexo::頁面絲滑滾動","content":"\n\n\n\n\n\n\n\n\n\n\n此篇為各筆記之整理，非原創內容，資料來源可見下方連結與文後參考資料\n步驟\n在 [Blogroot]\\themes\\xxxxxx\\source\\js創建新檔smooth.js 添加以下程式碼1&quot;use strict&quot;;function _typeof(e)&#123;return(_typeof=&quot;function&quot;==typeof Symbol&amp;&amp;&quot;symbol&quot;==typeof Symbol.iterator?function(e)&#123;return typeof e&#125;:function(e)&#123;return e&amp;&amp;&quot;function&quot;==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?&quot;symbol&quot;:typeof e&#125;)(e)&#125;!function()&#123;function r()&#123;var e,t,o,n,r,i;!D&amp;&amp;document.body&amp;&amp;(D=!0,e=document.body,t=document.documentElement,o=window.innerHeight,n=e.scrollHeight,M=0&lt;=document.compatMode.indexOf(&quot;CSS&quot;)?t:e,p=e,x.keyboardSupport&amp;&amp;window.addEventListener(&quot;keydown&quot;,a,!1),top!=self?E=!0:I&amp;&amp;o&lt;n&amp;&amp;(e.offsetHeight&lt;=o||t.offsetHeight&lt;=o)&amp;&amp;((r=document.createElement(&quot;div&quot;)).style.cssText=&quot;position:absolute; z-index:-10000; top:0; left:0; right:0; height:&quot;+M.scrollHeight+&quot;px&quot;,document.body.appendChild(r),v=function()&#123;i=i||setTimeout(function()&#123;r.style.height=&quot;0&quot;,r.style.height=M.scrollHeight+&quot;px&quot;,i=null&#125;,500)&#125;,setTimeout(v,10),window.addEventListener(&quot;resize&quot;,v,!1),(y=new $(v)).observe(e,&#123;attributes:!0,childList:!0,characterData:!1&#125;),M.offsetHeight&lt;=o&amp;&amp;((o=document.createElement(&quot;div&quot;)).style.clear=&quot;both&quot;,e.appendChild(o))),x.fixedBackground||(e.style.backgroundAttachment=&quot;scroll&quot;,t.style.backgroundAttachment=&quot;scroll&quot;))&#125;function l(s,d,u)&#123;var e,t,m,o,n;e=0&lt;(e=d)?1:-1,t=0&lt;(t=u)?1:-1,k.x===e&amp;&amp;k.y===t||(k.x=e,k.y=t,C=[],O=0),1!=x.accelerationMax&amp;&amp;((o=Date.now()-O)&lt;x.accelerationDelta&amp;&amp;(1&lt;(o=(1+50/o)/2)&amp;&amp;(o=Math.min(o,x.accelerationMax),d*=o,u*=o)),O=Date.now()),C.push(&#123;x:d,y:u,lastX:d&lt;0?.99:-.99,lastY:u&lt;0?.99:-.99,start:Date.now()&#125;),z||(o=j(),m=s===o||s===document.body,null==s.$scrollBehavior&amp;&amp;(n=X(o=s),null==N[n]&amp;&amp;(o=getComputedStyle(o,&quot;&quot;)[&quot;scroll-behavior&quot;],N[n]=&quot;smooth&quot;==o),N[n])&amp;&amp;(s.$scrollBehavior=s.style.scrollBehavior,s.style.scrollBehavior=&quot;auto&quot;),n=function e(t)&#123;t=Date.now();for(var o=0,n=0,r=0;r&lt;C.length;r++)&#123;var i=C[r],l=t-i.start,a=l&gt;=x.animationTime,c=a?1:l/x.animationTime;x.pulseAlgorithm&amp;&amp;(c=1&lt;=(l=c)?1:l&lt;=0?0:(1==x.pulseNormalize&amp;&amp;(x.pulseNormalize/=h(1)),h(l))),o+=l=i.x*c-i.lastX&gt;&gt;0,n+=c=i.y*c-i.lastY&gt;&gt;0,i.lastX+=l,i.lastY+=c,a&amp;&amp;(C.splice(r,1),r--)&#125;m?window.scrollBy(o,n):(o&amp;&amp;(s.scrollLeft+=o),n&amp;&amp;(s.scrollTop+=n)),d||u||(C=[]),C.length?P(e,s,1e3/x.frameRate+1):(z=!1,null!=s.$scrollBehavior&amp;&amp;(s.style.scrollBehavior=s.$scrollBehavior,s.$scrollBehavior=null))&#125;,P(n,s,0),z=!0)&#125;function e(e)&#123;D||r();var t=e.target;if(e.defaultPrevented||e.ctrlKey||m(p,&quot;embed&quot;)||m(t,&quot;embed&quot;)&amp;&amp;/\\.pdf/i.test(t.src)||m(p,&quot;object&quot;)||t.shadowRoot)return!0;var o=-e.wheelDeltaX||e.deltaX||0,n=-e.wheelDeltaY||e.deltaY||0;return T&amp;&amp;(e.wheelDeltaX&amp;&amp;w(e.wheelDeltaX,120)&amp;&amp;(o=e.wheelDeltaX/Math.abs(e.wheelDeltaX)*-120),e.wheelDeltaY&amp;&amp;w(e.wheelDeltaY,120)&amp;&amp;(n=e.wheelDeltaY/Math.abs(e.wheelDeltaY)*-120)),o||n||(n=-e.wheelDelta||0),1===e.deltaMode&amp;&amp;(o*=40,n*=40),(t=s(t))?!!function(e)&#123;if(e)return L.length||(L=[e,e,e]),e=Math.abs(e),L.push(e),L.shift(),clearTimeout(b),b=setTimeout(function()&#123;try&#123;localStorage.SS_deltaBuffer=L.join(&quot;,&quot;)&#125;catch(e)&#123;&#125;&#125;,1e3),e=120&lt;e&amp;&amp;f(e),!f(120)&amp;&amp;!f(100)&amp;&amp;!e&#125;(n)||(1.2&lt;Math.abs(o)&amp;&amp;(o*=x.stepSize/120),1.2&lt;Math.abs(n)&amp;&amp;(n*=x.stepSize/120),l(t,o,n),e.preventDefault(),void c()):!E||!q||(Object.defineProperty(e,&quot;target&quot;,&#123;value:window.frameElement&#125;),parent.wheel(e))&#125;function a(e)&#123;var t=e.target,o=e.ctrlKey||e.altKey||e.metaKey||e.shiftKey&amp;&amp;e.keyCode!==B.spacebar;document.body.contains(p)||(p=document.activeElement);var n=/^(textarea|select|embed|object)$/i,r=/^(button|submit|radio|checkbox|file|color|image)$/i;if(!(n=e.defaultPrevented||n.test(t.nodeName)||m(t,&quot;input&quot;)&amp;&amp;!r.test(t.type)||m(p,&quot;video&quot;)))&#123;n=e.target;var i=!1;if(-1!=document.URL.indexOf(&quot;www.youtube.com/watch&quot;))do&#123;if(i=n.classList&amp;&amp;n.classList.contains(&quot;html5-video-controls&quot;))break&#125;while(n=n.parentNode);n=i&#125;if(n||t.isContentEditable||o||(m(t,&quot;button&quot;)||m(t,&quot;input&quot;)&amp;&amp;r.test(t.type))&amp;&amp;e.keyCode===B.spacebar||m(t,&quot;input&quot;)&amp;&amp;&quot;radio&quot;==t.type&amp;&amp;H[e.keyCode])return!0;if(n=t=0,!(o=s(p)))return!E||!q||parent.keydown(e);switch(r=o.clientHeight,o==document.body&amp;&amp;(r=window.innerHeight),e.keyCode)&#123;case B.up:n=-x.arrowScroll;break;case B.down:n=x.arrowScroll;break;case B.spacebar:n=-(n=e.shiftKey?1:-1)*r*.9;break;case B.pageup:n=.9*-r;break;case B.pagedown:n=.9*r;break;case B.home:o==document.body&amp;&amp;document.scrollingElement&amp;&amp;(o=document.scrollingElement),n=-o.scrollTop;break;case B.end:n=0&lt;(r=o.scrollHeight-o.scrollTop-r)?r+10:0;break;case B.left:t=-x.arrowScroll;break;case B.right:t=x.arrowScroll;break;default:return!0&#125;l(o,t,n),e.preventDefault(),c()&#125;function t(e)&#123;p=e.target&#125;function c()&#123;clearTimeout(n),n=setInterval(function()&#123;Y=A=N=&#123;&#125;&#125;,1e3)&#125;function i(e,t,o)&#123;o=o?Y:A;for(var n=e.length;n--;)o[X(e[n])]=t;return t&#125;function s(e)&#123;var t=[],o=document.body,n=M.scrollHeight;do&#123;var r=A[X(e)];if(r)return i(t,r);if(t.push(e),n===e.scrollHeight)&#123;if(r=d(M)&amp;&amp;d(o)||u(M),E&amp;&amp;M.clientHeight+10&lt;M.scrollHeight||!E&amp;&amp;r)return i(t,j())&#125;else if(e.clientHeight+10&lt;e.scrollHeight&amp;&amp;u(e))return i(t,e)&#125;while(e=e.parentElement)&#125;function d(e)&#123;return&quot;hidden&quot;!==getComputedStyle(e,&quot;&quot;).getPropertyValue(&quot;overflow-y&quot;)&#125;function u(e)&#123;return&quot;scroll&quot;===(e=getComputedStyle(e,&quot;&quot;).getPropertyValue(&quot;overflow-y&quot;))||&quot;auto&quot;===e&#125;function m(e,t)&#123;return e&amp;&amp;(e.nodeName||&quot;&quot;).toLowerCase()===t.toLowerCase()&#125;function w(e,t)&#123;return Math.floor(e/t)==e/t&#125;function f(e)&#123;return w(L[0],e)&amp;&amp;w(L[1],e)&amp;&amp;w(L[2],e)&#125;function h(e)&#123;var t;return(e*=x.pulseScale)&lt;1?t=e-(1-Math.exp(-e)):(t=Math.exp(-1),t+=(e=1-Math.exp(-(e-1)))*(1-t)),t*x.pulseNormalize&#125;function o(e)&#123;for(var t in e)S.hasOwnProperty(t)&amp;&amp;(x[t]=e[t])&#125;var p,y,v,b,n,g,S=&#123;frameRate:150,animationTime:400,stepSize:100,pulseAlgorithm:!0,pulseScale:4,pulseNormalize:1,accelerationDelta:50,accelerationMax:3,keyboardSupport:!0,arrowScroll:50,fixedBackground:!0,excluded:&quot;&quot;&#125;,x=S,E=!1,k=&#123;x:0,y:0&#125;,D=!1,M=document.documentElement,L=[],T=/^Mac/.test(navigator.platform),B=&#123;left:37,up:38,right:39,down:40,spacebar:32,pageup:33,pagedown:34,end:35,home:36&#125;,H=&#123;37:1,38:1,39:1,40:1&#125;,C=[],z=!1,O=Date.now(),X=(g=0,function(e)&#123;return e.uniqueID||(e.uniqueID=g++)&#125;),Y=&#123;&#125;,A=&#123;&#125;,N=&#123;&#125;;if(window.localStorage&amp;&amp;localStorage.SS_deltaBuffer)try&#123;L=localStorage.SS_deltaBuffer.split(&quot;,&quot;)&#125;catch(e)&#123;&#125;var K,P=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||function(e,t,o)&#123;window.setTimeout(e,o||1e3/60)&#125;,$=window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver,j=(K=document.scrollingElement,function()&#123;var e,t;return K||((e=document.createElement(&quot;div&quot;)).style.cssText=&quot;height:10000px;width:1px;&quot;,document.body.appendChild(e),t=document.body.scrollTop,window.scrollBy(0,3),K=document.body.scrollTop!=t?document.body:document.documentElement,window.scrollBy(0,-3),document.body.removeChild(e)),K&#125;),R=window.navigator.userAgent,_=/Edge/.test(R),q=/chrome/i.test(R)&amp;&amp;!_,_=/safari/i.test(R)&amp;&amp;!_,V=/mobile/i.test(R),F=/Windows NT 6.1/i.test(R)&amp;&amp;/rv:11/i.test(R),I=_&amp;&amp;(/Version\\/8/i.test(R)||/Version\\/9/i.test(R)),R=(q||_||F)&amp;&amp;!V,W=!1;try&#123;window.addEventListener(&quot;test&quot;,null,Object.defineProperty(&#123;&#125;,&quot;passive&quot;,&#123;get:function()&#123;W=!0&#125;&#125;))&#125;catch(e)&#123;&#125;_=!!W&amp;&amp;&#123;passive:!1&#125;;var U=&quot;onwheel&quot;in document.createElement(&quot;div&quot;)?&quot;wheel&quot;:&quot;mousewheel&quot;;U&amp;&amp;R&amp;&amp;(window.addEventListener(U,e,_||!1),window.addEventListener(&quot;mousedown&quot;,t,!1),window.addEventListener(&quot;load&quot;,r,!1)),o.destroy=function()&#123;y&amp;&amp;y.disconnect(),window.removeEventListener(U,e,!1),window.removeEventListener(&quot;mousedown&quot;,t,!1),window.removeEventListener(&quot;keydown&quot;,a,!1),window.removeEventListener(&quot;resize&quot;,v,!1),window.removeEventListener(&quot;load&quot;,r,!1)&#125;,window.SmoothScrollOptions&amp;&amp;o(window.SmoothScrollOptions),&quot;function&quot;==typeof define&amp;&amp;define.amd?define(function()&#123;return o&#125;):&quot;object&quot;==(&quot;undefined&quot;==typeof exports?&quot;undefined&quot;:_typeof(exports))?module.exports=o:window.SmoothScroll=o&#125;();\n在[Blogroot]\\_config.xxxxxx.yml引入以下程式碼12345inject:  head:    - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot;  media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt; #教學用樣式  bottom:+   - &lt;script type=&quot;text/javascript&quot; src=&quot;/js/smooth.js&quot;&gt;&lt;/script&gt;\n\n\n參考來源\n頁面絲滑滾動\n\n","slug":"hexo-頁面絲滑滾動","date":"2022-01-19T10:57:45.000Z","categories_index":"Blog","tags_index":"Hexo","author_index":"Chico"}]